***이 글은 자바스크립트 닌자 비급을 참고해서 쓴 글입니다.***
# 1. 함수가 핵심이다
## 1.0 개요
    함수에서 중요한점은 자바스크립트에서 함수는 1종 객체라는 것이다. 이는 함수는 객체와
    같은 지위를 가지며, 객체처럼 취급할수 있다는 것을 의미한다. 데이터 타입과 마찬가지로,
    변수를 통해 함수를 참조하며, 리터럴로 함수를 선언하고, 함수를 다른 함수의 매개변수로
    전달할 수도 있다.

## 1.1 함수형 언어는 무엇이 다른가?
    자바스크립트에서 함수와 함수형 언어 특징이 중요한 이유는 함수가 실행의 기본 모듈 단위이기
    때문이다. 이에 진행하기 앞서 1종 객체의 개념을 알아보자
    자바스크립트 객체는 다음과 같은 기능적 특징이 있다.
    1. 리터럴로 생성될 수 있다.
    2. 변수, 배열, 엘리먼트, 다른 객체의 프로퍼티에 할당될 수 있다.
    3. 함수의 인자로 전달될 수 있다.
    4. 함수의 결과 값으로 반환될 수 있다.
    5. 동적으로 생성된 프로퍼티를 가질 수 있다.
    
    자바스크립트의 함수도 객체이므로 위와 같은 기능을 갖추고 있다. 이 외에도,
    함수는 호출될 수 있다는 특별한 기능이 있다.

### 1.1.1 브라우저 이벤트 루프
    GUI 데스크톱 애플리케이션을 만들어본적 있다면 대부분 비슷한 방식으로 개발이 된다.
    사용자 인터페이스를 설정하고, 이벤트가 발생하기를 기다리는 루프에 진입, 발생한 이벤트에 대한
    핸들러(또는 리스너)를 호출한다.
    이는 이벤트 루프를 실행하고 핸들러에게 전달하는 과정을 브라우저가 한다는 점 제외하면,
    브라우저에서의 프로그래밍도 별반 다르지 않다.
    우리가 할 일은 브라우저에서 발생할 여러 이벤트에 대해 핸들러를 설정하는 것이다.
    이벤트가 발생하면 큐에 들어가고 브라우저는 이벤트를 디스패치하며 해당 이벤트에 대해 설정된
    모든 이벤트 핸들러를 호출한다.
    이런 브라우저 이벤트들이 발생하는 시간은 정해진것이 아니라 순서 또한 예측할수 없다.
    따라서 브라우저가 이벤트를 처리하고 핸들러 함수를 호출하는 과정은 비동기라고 할수 있다.
    브라우저에서 발생하는 이벤트는 크게 4가지 인데
    1. 브라우저 이벤트 : 페이지 로드, 페이지 언로드 등
    2. 네트워크 이벤트 : Ajax 요청에 대한 응답 이벤트 등
    3. 사용자 이벤트 : 마우스 클릭, 마우스 움직임, 키 누르기 등
    4. 타이머 이벤트 : 시간 제한이 만료되거나, 주기적으로 발생하는 이벤트 등
    예시로 다음과 같은 코드를 보자
```javascript
function startup() {
    /*something Do*/
}
window.onload = startup();
```
    위 코드를 보면 함수를 정의하는 구문은 페이지를 로드할때 까지 실행되지 않는다.
    브라우저 이벤트는 싱글 스레드에서 동작하는데. 앞서 말한 이벤트 큐에 들어오는
    모든 이벤트는 큐에 들어온 순서대로 처리 된다.
    (나머지 이벤트는 현재 순서의 이벤트가 끝날때 까지 기다린다.)
    코드를 미리 만들고 나중에 실행하는 개념은 웹페이지에서 작동하는 자바스크립트의 핵심이고,
    대부분의 코드는 이벤트의 결과로 실행이 된다.
    여기서 이벤트를 큐에 넣는 브라우저 메커니즘은 이벤트 루프 모델 외부에서 작동하는데,
    이는 이벤트를 큐에 넣는 과정은 이벤트를 처리하는 스레드에서 처리하지 않는다.
    예를 들어 페이지에서 사용자가 마우스 클릭을 하면 브라우저는 click 이벤트를 이벤트 큐에 넣고,
    이벤트 루프는 click 이벤트를 처리하며, 이벤트 타입에 설정된 모든 이벤트 핸들러가 호출된다.
    이런 이벤트 핸들러는 콜백 함수라는 일반적인 개념이다.
    콜백이란 어떤 함수를 만들고 있는데, 브라우저가 나중에 그 함수를 호출하거나, 다른 코드가 
    그 함수를 호출하는 정도로 알면 된다. 다음 코드를 보자
```javascript
function useless(callback){
    return callback();
}
```
    위에서 알수 있는 점은 함수를 매개변수로 넣었다는 점과, 매개변수로 넘어온 함수를 호출한다는 점이다.
    여기서 매개변수로 넘어온 함수를 호출하는 것이 콜백이다.
    
## 1.2 함수 선언
    자바스크립트 함수는 함수 리터럴을 사용해 정의하는데, 네 가지 부분으로 구성되어 있다.
    1. function 키워드
    2. 함수 이름 (이는 생략할수 있고-익명함수, 만일 지정한다면 함수 이름은 유효한 자바스크립트 식별자)
    3. 쉼표로 구분된 매개변수 목록과 이 매개변수 목록을 둘러싸고 있는 괄호
    4. 중괄호로 둘러싸여 있는 자바스크립트 구문인 함수 본문
    
    만약 함수에 이름이 있다면, 그 이름은 함수가 정의된 모든 유효 범위에서 유효하고,
    최상위 단계에서 선언되었다면, window 객체에 그 함수 이름과 동일한 프로퍼티가 정의된다.
    그리고 window 객체에 정의된 프로퍼티는 해당 함수를 참조한다.

### 1.2.1 유효 범위와 함수
    함수를 선언할 때, 그 함수가 속한 유효 범위와 그 함수 자체가 만들어 내는 유효범위가
    그 함수 내의 어떤 영향을 주는지 신경 써야 한다.
    자바스크립트는 C영향을 받는 블록 구분자와는 다르게 작동한다.
    자바스크립트의 유효 범위는 블록이 아니라 함수에 의해 정의 된다.
    블록 안에서 선언한 어떤 요소의 유효 범위는 블록의 끝에서 끝나지 않는다.
    예를 들어보자
```javascript
if (window) {
    var x = 213;
}
alert(x); // 213
```
    다음과 같은 코드가 있을때 블록 구분자의 영향을 받는 대부분의 언어는
    에러가 나지만, 자바스크립트는 213이 표시가 된다,
    변수는 함수 내에서 변수가 선언된 부분부터 함수 끝부분까지 유효하고,
    블록이 중첩되더라도 변수 유효 범위에 영향을 주지 않는다.
    이름을 가진 함수는 그 함수가 선언된 함수 내부 전체에서 유효하다. (호이스팅)
    이런 유효 범위 규칙을 따르기 위해, 전역 콘텍스트는 모든 코드를 둘러싸고 있는
    하나의 커다란 함수처럼 작동한다.
    다음 코드를 살펴보자
```javascript
//(0) 함수 outer 선언 전
function outer(){
    //(1) 변수 a 선언 전
    var a = 1;
    //(2) 변수 a 선언 후
    function inner(){/**/}
    var b = 2;
    //(3) 변수 b 선언 후
    if(a == 1) {
        var c = 3;
        //(4) if문 내부
    }
    //(5) if문 바깥
}
outer();
//(6) outer 바깥
```
    다음과 같은 코드가 있을때 함수 outer, inner, 변수 a, b, c 의 유효 범위를 살펴보자
    먼저 (0)의 경우 오직 최상의 함수인 outer 만 유효 범위에 존재한다.
    (1) 의 경우 변수는 아직 선언 전이므로 유효 범위에 존재하지 않지만, 함수 inner 의 경우
    함수가 선언된 함수 내부 전체에 유효하므로 outer, inner 가 유효 범위에 존재한다.
    (2) 의 경우 변수 a가 선언 되었고, 함수 inner 가 outer 내부에 선언됬으므로 outer, inner, a 가 유효 범위에 존재한다.
    (3) 의 경우 (2) 와 마찬가지 맥락으로 outer, inner, a, b 가 유효 범위에 존재한다,
    (4) 의 경우 변수 a 는 함수 끝부분 까지 유효하므로 조건문을 통과하고 변수 c도 유효 범위에 존재하게 된다.
    즉, outer, inner, a, b, c 가 유효 범위에 존재한다.
    (5) 의 경우 조건문 밖이지만 여전히 변수 c는 함수가 끝나지 않았으므로 유효하다.
    즉 outer, inner, a, b, c 가 유효 하다.
    (6) 의 경우 함수가 종료 되었으므로 outer 내부에 선언된 모든것이 유효 범위에서 제외 즉, outer 만 유효하다.
    
    이것으로 알수 있는점을 정리하면,
    첫째 변수 a, b, c 는 그들이 정의된 부분부터 outer 끝까지 유효하다.
    둘째 함수는 그들의 유효 범위에서 미리 참조 될수 있다.
    셋째 블록 범위(예시에서는 조건문)가 종료되더라도 변수는 함수가 종료할때까지 유효 범위에 남아있다.
    
## 1.3 호출
    함수가 호출되는 방식은 코드 작동 방식에 큰 영향을 미치는데, 특히 this 매개변수가 어떻게
    설정되는지를 결정한다. 함수를 호출하는 방식은 네 가지 방식이 있는데,
    첫째, 함수로 호출
    둘째, 메서드로 호출
    셋째, 생성자로 호출
    마지막으로 함수의 apply(), call() 메서드를 통해 호출
    이중 마지막 방법을 제외하면 함수 호출 연산자는 함수를 참조하는 표현식과 괄호로 구성된다.
    그럼 먼저 함수를 작동하는 방법을 보기전에 함수에 전달할 인자들을 먼저 살펴보자

### 1.3.1 인자에서 함수의 매개변수까지
    함수를 호출할때 인자 목록을 제공하면 이 인자들은 함수를 정의할 때 지정한 매개변수에
    순서대로 할당된다. 인자 개수와 매개변수의 개수가 다르더라도 에러는 발생하지 않는다.
    만일 매개변수보다 많은 인자를 할당하면 남은 인자들은 무시되고,
    매개변수보다 적은 인자를 할당하면 남은 매개변수는 undefined 로 할당된다.
    그리고 모든 함수 호출에는 암묵적으로 arguments 와 this 두 매개변수가 넘어온다.
    arguments 매개변수는 함수에 전달된 모든 인자를 담고 있는 컬렉션으로
    배열 인덱스 표기법으로 개별 인자값을 얻을 수 있다. 그러나 arguments 매개변수는 배열이 아니다.
    단지 유사 배열로 사용성에 있어서 배열보다는 제한이 있다.
    this 매개변수는 함수 호출과 관계된 객체를 참조하며, 이를 함수 콘텍스트라고 한다.
    이는 함수를 어떻게 호출할 것인가와 관련이 있다.
    
### 1.3.2 함수로 호출
    함수로 호출은 가장 기본적인 호출 형태로 () 연산자를 사용하여 함수를 호출하는 것이다.
```javascript
function star() {};
star();

var light = function() {};
light();
```
    이 상태로 호출되었을 때, 함수 콘텍스트는 전역 콘텍스트이다.
    즉, 함수로 호출하는 경우 암묵적으로 모든 함수의 소유자는 window 객체이다.
    
### 1.3.3 메서드로 호출
    함수를 객체의 프로퍼티로 할당하고, 그 프로퍼티를 사용하여 참조에 의한 호출이 일어나면
    함수는 객체의 메서드로 호출된다.
```javascript
var obj = {};
obj.star = function() {};
obj.star();
```
    여기서 객체가 함수 콘텍스트가 되고, 함수 내에서 this 매개변수로 참조할 수 있다.
    이는 자바스크립트로 객체 지향 코드를 작성하게 해주는 주요 수단이다.
    다음 코드를 보면서 함수 호출과 메서드 호출의 차이점을 이해해보자
```javascript
function star() {return this;}
console.info(star() === window); //true

var light = star;
console.info(light() === window); //true

var starlight1 = {
    night: star
};
console.info(starlight1.night() === starlight1); //true

var starlight2 = {
    night: star
};
console.info(starlight2.night() === starlight2); //true
```
    여기서 star 함수는 오직 자신의 함수 콘텍스트만 반환하기 때문에 이를 통해
    함수 밖에서 해당 호출에 대한 함수 콘텍스트가 무엇인지를 확인할 수 있다.
    여기서 함수 star 를 변수 light 와 객체 starlight 객체가 참조했는데 이는 복사본을
    만드는 것이 아니라는 점을 유념해야한다.
    이 예시를 보면 함수 star 를 어떻게 호출하느냐에 따라 함수 콘텍스트가 변하는것을 알수 있다.
    자세히 보면 객체 starlight1, starlight2 는 동일한 함수 인스턴스를 공유하고 있지만,
    함수가 실행되면 그 함수가 호출된 객체에 접근하고, 호출에 따라 필요한 연산을 수행한다.
    이는 객체마다 별도의 함수 복사본을 생성할 필요가 없다는 뜻이기도 하다.
    
### 1.3.4 생성자로 호출
    생성자로 호출하려면 함수 호출 앞에 new 키워드를 붙인다.
    생성자로 호출하면 다음과 같이 특별한 행동이 일어난다.
    첫째, 비어있는 객체가 생성된다,
    둘째, 새로 생성된 객체는 this 매개변수로 생성자 함수에 전달되고, 생성자 함수의 함수 콘텍스트가 된다.
    마지막으로, 명시적인 반환 값이 없다면 새로 생성된 객체가 생성자의 값으로 반환된다.
    다음 코드를 보자
```javascript
function Star() {
    this.night = function() { return this; };
}

var starlight1 = new Star();
var starlight2 = new Star();
console.info(starlight1.night() === starlight1); //true
console.info(starlight2.night() === starlight2); //true
```
    이 코드에서 Star 라는 함수를 만들었고, new 키워드를 사용하여 함수를 호출하면
    빈 객체 인스턴스가 생성되고, 생성자 함수에 빈 객체 인스턴스가 this로 전달된다.
    생성자 함수는 this 객체에 night 라는 프로퍼티를 생성하고 함수를 할당한다.
    결국 새로 생성된 객체는 night 프로퍼티를 갖게된다.
    
    생성자 함수는 보통 함수와 다르게 작성하는데,
    생성자 함수는 특정한 상태로 초기화된 객체를 만들어 반환하기 위해서 사용한다.
    그런데 이 생성자 함수를 일반 함수처럼 호출하는것이 가능하고 객체의 프로퍼티로도 설정할수가 있다.
```javascript
var starlight = Star();
```    
    하지만 결과는 window 객체에 night 프로퍼티가 만들어지고, 반환값은 window 이며
    window 객체가 starlight 변수에 저장된다.
    결국 생성자 함수는 생성자로 호출하지 않으면 쓸모가 없다.
    결국 메서드와 생성자를 구분하도록 명명 규칙이 필요한데, 생성자의 이름을 명사, 대문자로 시작하도록 약속했다.

### 1.3.5 apply() 메서드와 call() 메서드를 사용한 호출
    실행되는 함수에 this 매개변수가 암묵적으로 전달되는데, 만일 this를 명시적으로 설정하고
    싶을때 apply() 와 call() 메서드중 하나를 사용하여 함수 콘텍스트를 지정할 수 있다.
    apply() 메서드를 사용하여 함수를 호출하려면 두개의 매개변수를 전달해야 하는데,
    하나는 함수 콘텍스트로 사용할 객체와 인자값을 담은 배열이다,
    call() 메서드도 비슷하지만 인자를 배열로 전달하지 않고, 인자 목록으로 직접 전달한다.
```javascript
function star(){
    var result = 0;
    for (var n = 0; n < arguments.length; n++) {
        result += arguments[n];
    }
    this.result = result;
}

var light1 = {};
var light2 = {};

star.apply(light1, [1,2,3,4]);
star.call(light2,5,6,7,8);

console.info(light1.result); //10
console.info(light2.result); //26
```
    위 코드를 보면 함수 star 는 모든 인자를 더하여 값을 더한 결과를
    함수 콘텍스트의 result 라는 프로퍼티에 저장한다.
    apply(), call() 둘다 우리가 선택한 객체로 바꿔치기 된것을 볼수 있다.
    즉, 함수의 콘텍스트를 강제로 지정한 것이다, 이를 응용해보자
 ```javascript
function forEach(list, callback){
    for (var n = 0; n < list.length; n++){
        callback.call(list[n], n);
    }
}

var night = ['star','light','lunar'];
forEach(night, function(index){
   console.info(this == night[index]); //true, true. true
});
```
    이는 현재 순회 요소를 콜백 함수의 콘텍스트로 지정하며, 인덱스 값은
    콜백 함수에 단일 매개변수로 전달을 해서 비교한 모습이다.