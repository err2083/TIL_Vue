# 1. 비동기

**이 글은 You Don't Know JS을 참고해서 쓴 글입니다.**

## 1.0. 지금과 나중

자바스크립트의 비동기성에서 가장 중요한 부분은 지금 실행하는 부분과 나중에 실행하는 부분의 간극이다.
이러한 간극은 입력 대기, DB/File 시스템 조회, 네트워크를 경유한 데이터 송신 후 응답, 일정한 시간동안 반복적인 작업(-애니메이션) 등이 있다.

## 1.1 프로그램 덩이

자바스크립트 프로그램은 여러 개의 덩이(Chunk) 로 구성되며, 지금 실행중인 덩이 하나와 나중에 실행할 덩이 들로 구성하게 된다. 여기서 주의할점은 '지금' 의 다음은 '나중' 이 아니다.
대표적인 예시로 네트워크 통신을 보자

```javascript
const { data } = ajax('url');
console.log(data); // undefined
```

표준 ajax 요청은 동기적으로 작동하지 않아서 함수 결과값을 변수에 담기전에 '지금' 실행하는 부분이 작동한다. '지금'부터 '나중'까지 기다리는 가장 간단한 방법으로 콜백 함수를 사용할수 있다.

```javascript
ajax('url', ( data ) => { console.log(data) }); // response
```

또는 동기적인 네트워크 방식을 사용할수도 있지만 이는 UI 를 마비시키므로 논점에서 제외하겠다.

다음은 간단한 자바스크립트 코드이다

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log(answer);
}

var answer = now();
setTimeout( later, 1000 ); // 1초 후에 later 메소드를 실행하겠다.
```

이 코드는 '지금' 과 '나중' 이라는 두 덩이로 이루어진 코드이다.
프로그램을 시작하면 '지금' 이라는 덩이가 바로 실행이 되고 '나중' 이벤트를 설정하는 setTimeout 에 의해 '나중' 덩이가 실행된다.

### 1.1.1 비동기 콘솔

console.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문이다. 이런 일들이 물밑에서 처리되고 있는 줄도 모르겠지만 페이지/UI 관점에서 보면 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 드물긴 하지만 이런 현상이 가끔가다 관찰되는 코드를 보자

```javascript
var a = {
    index: 1
};
console.log(a); // ???
a.index++;
```

console.log() 메서드가 실행되면 당연히 객체 스냅샷 {index: 1} 이 콘솔에 찍힌 다음 a.index++ 이 실핼될것이다. 그런데 간혹 브라우저가 콘솔 I/O 백그라운드 전환하는 것이 좋겠다고 결정하면 출력이 지연될 수 있다. 그래서 {index: 2} 로 나올때가 있다.

## 1.2 이벤트 루프

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 처리하는 실행기일 뿐이다.
자바스크립트 엔진은 혼자서는 못하고 반드시 호스팅(대표적으로 브라우저)에서 실행된다. 자바스크립트는 여러 환경이 있지만, 스레드는 항상 공통으로 여러 덩이를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 이벤트 루프라는 장치다 즉, 덩이를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경 몫이다.

콜백 함수를 예를 들면 이것은 마치 자바스크립트 엔진이 호스팅 환경에게 네트워크 요청이 끝나 결과 데이터가 만들어질때 다시 불러달라는 의미이다. 그 후 브라우저는 네트워크를 통해 리스닝하게 되고, 데이터가 도착하면 콜백함수를 이벤트 루프에 넣어 실행 스케줄링 한다.

다음은 이벤트 루프의 간단한 코드 형태이다 (실제로는 이렇게 되어있지는 않다)

```javascript
var eventLoop = [];
var event;
while (true) {
    // tick 발생
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
        event();
    }
}
```

반복문의 매 순회를 틱 이라고 하며 틱이 발생할때마다 큐에 적재된 이벤트를 꺼내어 실행하는 형태이다.

setTimeout 에 대해 다시 보면 이는 타이머를 설정해주는 함수로 타이머가 끝나면 환경에 콜백을 이벤트 루프에 삽입한 뒤 틱에서 실행하는 형태이다. 즉, 적어도 지정한 시간 이전에 콜백이 실행되지 않음을 보장할수는 있지만 정확한 타이밍으로 동작하지는 않는다.

## 1.3 병렬 스레딩

비동기는 앞서 말했듯이 '지금'과 '나중' 사이의 간극이고 병렬은 동시에 일어나는 일들과 연관된다.
프로세스와 스레드는 가장 많이 쓰는 병렬 컴퓨터 구조로 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유한다.

반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할수는 없다. 병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습이다.

병렬 실행 스레드 인터리빙과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위에서 일어난다.
예를 들어

```javascript
function later() {
    answer = answer * 2;
    console.log(answer)l
}
```

later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행하는 스레드애서는 여러 상이한 저수준의 작업들이 일어날수 있다. 예컨데 answer = asnwer * 2 는 현재 answer 조회 -> 곱셈 연산 수행 -> answer 변수에 저장

단일 스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 문제가 없다. 하지만 병렬 시스템은 다르다.

```javascript
var a = 20;
function foo() {
    a = a + 1;
}
function bar() {
    a = a * 2;
}
ajax('url', foo);
ajax('url2', bar);
```

자바스크립트는 단일 스레드 이므로 foo -> bar 이면 a 는 42, 반대이면 41 이 된다.

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡하다.
foo 메서드의 경우 a 조회 -> 더하기 연산 수행 -> a 저장의 프로세스를 거치고
bar 메서드의 경우 a 조회 -> 곱하기 연산 수행 -> a 저장의 프로세스를 거치는데 섞이게 되는경우 결과값을 예측할수 없게된다.

자바스크립트는 스레드 간의 데이터공유를 하지 않으므로 비결정성의 수즌은 문제가 되지않지만 위의 코드를 보면 항상 결정적일 수도 없다.

### 1.3.1 완전-실행

자바스크립트의 작동 모드는 단잉-스레드 이므로 내부 코드는 원자적이다. 즉, 함수 전체 코드가 끝나야 다른 함수가 실행된다는 뜻이다. 이를 완전-실행이라고 한다.
흔히 잦바스크립트에서 함수 순서에 따른 비결정성을 경합 조건이라고 하는데, 누가 먼저 실행되나 내기하는 경합같다는 의미에서이다.

## 1.4 동시성

스크롤바를 아래로 내리면 계속 리스트가 갱신되는 페이지를 만든다고 생각할때, 이런 기능은 적어도 2개의 분리된 로직을 동시에 실행할수 있어야 한다. 첫 로직는 스크롤 이벤트 발생, 두번째 로직는 네트워크 응답을 받고 그리는 작업이다.

동시성은 복수의 로직이 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다.

### 1.4.1 비상호 작용

복수의 로직이 이벤트를 동시에 인터리빙할때 서로가 상호작용이 일어나지않는다면 비결정성은 완벽하게 수용하능하다. 순서와도 상관없으니 언제나 결과를 예측할수 있다.

### 1.4.2 상호 작용

순서에 따라 결과에 달라지는 경우 상호 작용의 순서를 잘 조정해서 결과를 예측할수 있게 해주어야한다.
예를 들면 함수 호출에 관문을 두는 형태이다.

```javascript
var a, b;
function foo(x) {
    a = x * 2;
    baz()
};
function bar(y) {
    b = y * 2;
    baz();
};
function baz() {
    console.log(a + b);
}
ajax('url', foo);
ajax('url2', bar);
```

위 코드는 foo, bar 중 어느쪽이 먼저 실행하더라도 다른 하나는 결과값이 없는 상태니 문제가 된다.
이럴때 baz 함수 호출 조건에 (a && b) 등의 관문을 두면 비결정성을 어느정도 수용할수 있게 된다.

### 1.4.3 협동

협동적 동시성은 동시성을 조정하는 다른 방안으로 실행 시간이 오래 걸리는 로직을 여러 단계/배치로 쪼개어 다른 동시 로직이 각자 이벤트 루프 큐에 인터리빙 하도록 하는 게 목표이다.
간단한 예시를 보면

```javascript
var res = [];
function response(data){
    var chunk = data.splice(0, 1000);
    res = res.concat(chunk.map((val) => val * 2);
    if (data.length > 0) {
        setTimeout(() => response(data), 0);
    }
}
```

setTimeout(..., 0) 은 비동기 스케줄링의 스킬중 하나로 함수를 현재 이벤트 루프 큐의 맨 끝에 넣어주는 방법이다. 즉, 코드를 보면 한번에 처리되어야할 작업이 1000개씩 분리되어 현재 로직을 처리하고 남은 부분을 이벤트 루프 끝에 넣어서 처리하는 방식으로 하는 것이다.

## 1.5 잡

잡 큐는 ES6 부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 간단하게 설명하자면 잡 큐는 이벤트 루프 큐에서 매 틱의 끝자락에 매달려 있는 큐 라고 생각하면 좋다. 즉, 이벤트 루프 큐에 추가하는것이 아닌 현재 틱의 잡 큐 끝부분에 추가가 된다. 이건 마치 '나중'에 처리해야할 우선순위가 높은 작업이라고 할수 있다.

```javascript
console.log('A');
setTimeout(() => console.log('B'), 0);
schedule(() => { // 이론적인 API 라 가정
    console.log('C');
    schedule(() => console.log('D'));
})
```

위와 같은 코드가 있을때 A C D B 순서로 출력하게 된다.

## 1.6 문 순서

자바스크립트 엔진은 코드를 컴파일 하기 전에 문 수서를 재정렬 하여 실행 시간을 줄일 여지가 있는지 확인한다. 물론 최종 결과가 뒤바뀌지 않도록 안전하게 최적화 한다. 여기서 말하고자 하는 바는 소스 코드 순서(위 -> 아래)와 컴파일 후 실행순서는 사실상 아무 관련이 없다는 것이다.

## 2.0 콜백

