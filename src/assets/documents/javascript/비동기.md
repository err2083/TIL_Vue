# 1. 비동기

**이 글은 You Don't Know JS을 참고해서 쓴 글입니다.**

## 1.0. 지금과 나중

자바스크립트의 비동기성에서 가장 중요한 부분은 지금 실행하는 부분과 나중에 실행하는 부분의 간극이다.
이러한 간극은 입력 대기, DB/File 시스템 조회, 네트워크를 경유한 데이터 송신 후 응답, 일정한 시간동안 반복적인 작업(-애니메이션) 등이 있다.

## 1.1 프로그램 덩이

자바스크립트 프로그램은 여러 개의 덩이(Chunk) 로 구성되며, 지금 실행중인 덩이 하나와 나중에 실행할 덩이 들로 구성하게 된다. 여기서 주의할점은 '지금' 의 다음은 '나중' 이 아니다.
대표적인 예시로 네트워크 통신을 보자

```javascript
const { data } = ajax('url');
console.log(data); // undefined
```

표준 ajax 요청은 동기적으로 작동하지 않아서 함수 결과값을 변수에 담기전에 '지금' 실행하는 부분이 작동한다. '지금'부터 '나중'까지 기다리는 가장 간단한 방법으로 콜백 함수를 사용할수 있다.

```javascript
ajax('url', ( data ) => { console.log(data) }); // response
```

또는 동기적인 네트워크 방식을 사용할수도 있지만 이는 UI 를 마비시키므로 논점에서 제외하겠다.

다음은 간단한 자바스크립트 코드이다

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log(answer);
}

var answer = now();
setTimeout( later, 1000 ); // 1초 후에 later 메소드를 실행하겠다.
```

이 코드는 '지금' 과 '나중' 이라는 두 덩이로 이루어진 코드이다.
프로그램을 시작하면 '지금' 이라는 덩이가 바로 실행이 되고 '나중' 이벤트를 설정하는 setTimeout 에 의해 '나중' 덩이가 실행된다.

### 1.1.1 비동기 콘솔

console.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문이다. 이런 일들이 물밑에서 처리되고 있는 줄도 모르겠지만 페이지/UI 관점에서 보면 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 드물긴 하지만 이런 현상이 가끔가다 관찰되는 코드를 보자

```javascript
var a = {
    index: 1
};
console.log(a); // ???
a.index++;
```

console.log() 메서드가 실행되면 당연히 객체 스냅샷 {index: 1} 이 콘솔에 찍힌 다음 a.index++ 이 실핼될것이다. 그런데 간혹 브라우저가 콘솔 I/O 백그라운드 전환하는 것이 좋겠다고 결정하면 출력이 지연될 수 있다. 그래서 {index: 2} 로 나올때가 있다.

## 1.2 이벤트 루프

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 처리하는 실행기일 뿐이다.
자바스크립트 엔진은 혼자서는 못하고 반드시 호스팅(대표적으로 브라우저)에서 실행된다. 자바스크립트는 여러 환경이 있지만, 스레드는 항상 공통으로 여러 덩이를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 이벤트 루프라는 장치다 즉, 덩이를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경 몫이다.

콜백 함수를 예를 들면 이것은 마치 자바스크립트 엔진이 호스팅 환경에게 네트워크 요청이 끝나 결과 데이터가 만들어질때 다시 불러달라는 의미이다. 그 후 브라우저는 네트워크를 통해 리스닝하게 되고, 데이터가 도착하면 콜백함수를 이벤트 루프에 넣어 실행 스케줄링 한다.

다음은 이벤트 루프의 간단한 코드 형태이다 (실제로는 이렇게 되어있지는 않다)

```javascript
var eventLoop = [];
var event;
while (true) {
    // tick 발생
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
        event();
    }
}
```

반복문의 매 순회를 틱 이라고 하며 틱이 발생할때마다 큐에 적재된 이벤트를 꺼내어 실행하는 형태이다.

setTimeout 에 대해 다시 보면 이는 타이머를 설정해주는 함수로 타이머가 끝나면 환경에 콜백을 이벤트 루프에 삽입한 뒤 틱에서 실행하는 형태이다. 즉, 적어도 지정한 시간 이전에 콜백이 실행되지 않음을 보장할수는 있지만 정확한 타이밍으로 동작하지는 않는다.

## 1.3 병렬 스레딩

비동기는 앞서 말했듯이 '지금'과 '나중' 사이의 간극이고 병렬은 동시에 일어나는 일들과 연관된다.
프로세스와 스레드는 가장 많이 쓰는 병렬 컴퓨터 구조로 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유한다.

반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할수는 없다. 병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습이다.

병렬 실행 스레드 인터리빙과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위에서 일어난다.
예를 들어

```javascript
function later() {
    answer = answer * 2;
    console.log(answer)l
}
```

later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행하는 스레드애서는 여러 상이한 저수준의 작업들이 일어날수 있다. 예컨데 answer = asnwer * 2 는 현재 answer 조회 -> 곱셈 연산 수행 -> answer 변수에 저장

단일 스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 문제가 없다. 하지만 병렬 시스템은 다르다.

```javascript
var a = 20;
function foo() {
    a = a + 1;
}
function bar() {
    a = a * 2;
}
ajax('url', foo);
ajax('url2', bar);
```

자바스크립트는 단일 스레드 이므로 foo -> bar 이면 a 는 42, 반대이면 41 이 된다.

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡하다.
foo 메서드의 경우 a 조회 -> 더하기 연산 수행 -> a 저장의 프로세스를 거치고
bar 메서드의 경우 a 조회 -> 곱하기 연산 수행 -> a 저장의 프로세스를 거치는데 섞이게 되는경우 결과값을 예측할수 없게된다.

자바스크립트는 스레드 간의 데이터공유를 하지 않으므로 비결정성의 수즌은 문제가 되지않지만 위의 코드를 보면 항상 결정적일 수도 없다.

### 1.3.1 완전-실행

자바스크립트의 작동 모드는 단잉-스레드 이므로 내부 코드는 원자적이다. 즉, 함수 전체 코드가 끝나야 다른 함수가 실행된다는 뜻이다. 이를 완전-실행이라고 한다.
흔히 잦바스크립트에서 함수 순서에 따른 비결정성을 경합 조건이라고 하는데, 누가 먼저 실행되나 내기하는 경합같다는 의미에서이다.

## 1.4 동시성

스크롤바를 아래로 내리면 계속 리스트가 갱신되는 페이지를 만든다고 생각할때, 이런 기능은 적어도 2개의 분리된 로직을 동시에 실행할수 있어야 한다. 첫 로직는 스크롤 이벤트 발생, 두번째 로직는 네트워크 응답을 받고 그리는 작업이다.

동시성은 복수의 로직이 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다.

### 1.4.1 비상호 작용

복수의 로직이 이벤트를 동시에 인터리빙할때 서로가 상호작용이 일어나지않는다면 비결정성은 완벽하게 수용하능하다. 순서와도 상관없으니 언제나 결과를 예측할수 있다.

### 1.4.2 상호 작용

순서에 따라 결과에 달라지는 경우 상호 작용의 순서를 잘 조정해서 결과를 예측할수 있게 해주어야한다.
예를 들면 함수 호출에 관문을 두는 형태이다.

```javascript
var a, b;
function foo(x) {
    a = x * 2;
    baz()
};
function bar(y) {
    b = y * 2;
    baz();
};
function baz() {
    console.log(a + b);
}
ajax('url', foo);
ajax('url2', bar);
```

위 코드는 foo, bar 중 어느쪽이 먼저 실행하더라도 다른 하나는 결과값이 없는 상태니 문제가 된다.
이럴때 baz 함수 호출 조건에 (a && b) 등의 관문을 두면 비결정성을 어느정도 수용할수 있게 된다.

### 1.4.3 협동

협동적 동시성은 동시성을 조정하는 다른 방안으로 실행 시간이 오래 걸리는 로직을 여러 단계/배치로 쪼개어 다른 동시 로직이 각자 이벤트 루프 큐에 인터리빙 하도록 하는 게 목표이다.
간단한 예시를 보면

```javascript
var res = [];
function response(data){
    var chunk = data.splice(0, 1000);
    res = res.concat(chunk.map((val) => val * 2);
    if (data.length > 0) {
        setTimeout(() => response(data), 0);
    }
}
```

setTimeout(..., 0) 은 비동기 스케줄링의 스킬중 하나로 함수를 현재 이벤트 루프 큐의 맨 끝에 넣어주는 방법이다. 즉, 코드를 보면 한번에 처리되어야할 작업이 1000개씩 분리되어 현재 로직을 처리하고 남은 부분을 이벤트 루프 끝에 넣어서 처리하는 방식으로 하는 것이다.

## 1.5 잡

잡 큐는 ES6 부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 간단하게 설명하자면 잡 큐는 이벤트 루프 큐에서 매 틱의 끝자락에 매달려 있는 큐 라고 생각하면 좋다. 즉, 이벤트 루프 큐에 추가하는것이 아닌 현재 틱의 잡 큐 끝부분에 추가가 된다. 이건 마치 '나중'에 처리해야할 우선순위가 높은 작업이라고 할수 있다.

```javascript
console.log('A');
setTimeout(() => console.log('B'), 0);
schedule(() => { // 이론적인 API 라 가정
    console.log('C');
    schedule(() => console.log('D'));
})
```

위와 같은 코드가 있을때 A C D B 순서로 출력하게 된다.

## 1.6 문 순서

자바스크립트 엔진은 코드를 컴파일 하기 전에 문 수서를 재정렬 하여 실행 시간을 줄일 여지가 있는지 확인한다. 물론 최종 결과가 뒤바뀌지 않도록 안전하게 최적화 한다. 여기서 말하고자 하는 바는 소스 코드 순서(위 -> 아래)와 컴파일 후 실행순서는 사실상 아무 관련이 없다는 것이다.

## 2.0 콜백

함수 안의 문은 예측 가능한 순서대로 실행되지만 함수 단위의 실행 순서는 이벤트에 따라 달라질수 있다.
콜백은 큐에서 대기 중인 함수가 처리되자마자 본 프로그램으로 돌아올 목적지이다.
이는 자바스크립트 언어에서 가장 기본적인 비동기 패턴이다.

## 2.1 연속성

다음 간단한 콜백 예제를 보자

```javascript
// A
ajax('url', function() {
    // B
});
// C
```

A,C 는 비동기 '지금', B 는 '나중' 에 해당하는 코드가 된다. '지금'에 해당하는 부분이 실행되고 비결정적인 시간 동안 중지되었다가 ajax 호출이 끝날때 중지되기 이전 시점으로 돌아와 '나중' 부분이 실행된다. 다시 말해, 콜백은 프로그램의 연속성을 캡슐화한 장치이다.

## 2.2 두뇌는 순차적이다

사람은 기본적으로 싱글태스커에 가깝다. 동시에 일을 한다는 것은 재빠른 콘텍스트 교환기를 통해 행동하고 있을 뿐이다. 여기서 말하고 싶은점은 인간의 두뇌가 이벤트 루프 큐처럼 동작한다는 사실이다.

### 2.2.1 실행 vs 계획

두뇌는 이벤트 루프 큐처럼 동작한다고 했지만 사실은 그리 단순하지는 않다. 하루를 어떤 순서로 계획한다는것 자체가 이미 어긋나게 된다. 예를 들면 오늘 할 일을 이렇게 작성하지는 않을 것이다

"오늘 가게에 가서 우유를 가야겠다. 그런데 가능 도중에 친구에게 전화가 올 것이고, 나는 전화를 받으면서 인사를 하겠지. 그리고 눈 앞의 돌 다리를 하나씩 건너면서 ..."

이렇게 모든 일을 예측하면서 할 일을 계획할수는 없다. 이것이 비동기 코드 작성이 어려운 이유이다. 사람이 비동기 흐름을 생각하는 일 자체가 부담스럽기 때문이다.

### 2.2.2 중첩/연쇄된 콜백

```javascript
listen('click', function handler(evt) {
    setTimeout(function request() {
        ajax('url', function response(text) {
            // logic
        })
    })
})
```

이른바 이런 콜백 지옥 이라는 코드를 자주 보았을 것이다. 이는 단순히 가독성을 떠나서 심각한 문제를 가지고 있다. 차근차근 설명하면
우선 클릭 이벤트 대기 -> 타이머 작동까지 대기 -> ajax 응답 받을때 까지 대기 순으로 진행하고 이후 처음으로 되돌아온다. 이것의 문제점은
첫째, 위의 순서는 수 많은 경우의 수 중 하나의 실행에 불과하다는 것이다. 타이머 작동에 문제가 생길수도 있고, ajax 에 문제가 생길수도 있는것이다.
이번엔 다른 문제를 가지고 있는 코드를 보자

```javascript
doA(function() {
    doB();
    doC(function() {
        doD();
    })
    doE();
});
doF();
```

다음 코드 순서는 A - F - B - C - E - D 가 될것이다. 그런데 만약 doA 와 doC가 비동기 코드가 아니라면 어떻게 될까? 그럼 순서는 A - B - C - D - E - F 가 될것이다.
앞서 예시를 든 문제들에 대해 모든 경우의 수를 하드코딩한다면 이는 코드가 너무 복잡해져 수정이 난처하게 될것이다. 이것이 콜백의 첫번째 단점이다.

## 2.3 믿음성 문제

콜백의 가장 큰 문제점은 앞서 말한 콘텍스트 교환기 이다. 대부분의 콜백을 넘겨주는 함수는 서드 파티가 제공한 유탈리티의 경우가 대부분인데, 내가 작성하는 코드임에도 불구하고 서드 파티의 로직에 의존해야하는 제어의 역전이라는 상황에 마주하게 된다.

### 2.3.1 다섯 마리 콜백 이야기

이해를 돕기 위한 예를 하난 들어보자
당신은 전자상거래 결제 시스템을 구축하는 담당자라고 해보자. 그리고 실제 고객이 결재하는 부분은
다음과 같이 코드를 구성했다고 생각해보자

```javascript
analytics.trackPurchase(purchaseData, function() {
    chargeCreditCard();
    displayThankyouPage();
})
```

시간이 흘러 결제하는 부분에서 문제가 생겼다고 연락이 왔다. 문제 내용은 결제가 5번 이루어졌다는것이다.
로그를 분석해보니 결제를 하는 로직이 5번이나 실행이 된것이다. 콜백을 한번도 실행하지 않을 수도 있고, 일찍 호출하거나 늦게 호출할수도 있는것이다. 이럴때마다 우리가 경우의 수를 모두 따져서 코드를 작성하기란 힘든일이다. 이것이 콜백의 가장 큰 두번째 문제이다.

## 2.4 콜벡을 구하라

이러한 콜백의 문제를 해결하고자 에러를 처리하려고 분할 콜백 기능을 제공하는 API 가 있다.
또는 에러 우선 스타일 이라는 콜백 패턴 또한 많이 쓴다. 그러나 이것들도 반복적인 콜백 호출을 방지하거나 등 의 기능은 존재하지 않는다. 이러한 문제를 해결하기 위해 지금까지 개발자들은 오버헤드를 넣는 식으로 손수 장치를 마련해 왔다. 콜백을 한 번도 호출하지 않는다면 타임아웃을 걸어놓았다던가, 주어진 API 를 항상 예측 가능한 비동기 콜백으로 호출하든가의 유틸리티를 작성해왔다.

## 3.0 프라미스


