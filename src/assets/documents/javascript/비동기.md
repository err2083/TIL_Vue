# 1. 비동기

**이 글은 You Don't Know JS을 참고해서 쓴 글입니다.**

## 1.0. 지금과 나중

자바스크립트의 비동기성에서 가장 중요한 부분은 지금 실행하는 부분과 나중에 실행하는 부분의 간극이다.
이러한 간극은 입력 대기, DB/File 시스템 조회, 네트워크를 경유한 데이터 송신 후 응답, 일정한 시간동안 반복적인 작업(-애니메이션) 등이 있다.

## 1.1 프로그램 덩이

자바스크립트 프로그램은 여러 개의 덩이(Chunk) 로 구성되며, 지금 실행중인 덩이 하나와 나중에 실행할 덩이 들로 구성하게 된다. 여기서 주의할점은 '지금' 의 다음은 '나중' 이 아니다.
대표적인 예시로 네트워크 통신을 보자

```javascript
const { data } = ajax('url');
console.log(data); // undefined
```

표준 ajax 요청은 동기적으로 작동하지 않아서 함수 결과값을 변수에 담기전에 '지금' 실행하는 부분이 작동한다. '지금'부터 '나중'까지 기다리는 가장 간단한 방법으로 콜백 함수를 사용할수 있다.

```javascript
ajax('url', ( data ) => { console.log(data) }); // response
```

또는 동기적인 네트워크 방식을 사용할수도 있지만 이는 UI 를 마비시키므로 논점에서 제외하겠다.

다음은 간단한 자바스크립트 코드이다

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log(answer);
}

var answer = now();
setTimeout( later, 1000 ); // 1초 후에 later 메소드를 실행하겠다.
```

이 코드는 '지금' 과 '나중' 이라는 두 덩이로 이루어진 코드이다.
프로그램을 시작하면 '지금' 이라는 덩이가 바로 실행이 되고 '나중' 이벤트를 설정하는 setTimeout 에 의해 '나중' 덩이가 실행된다.

### 1.1.1 비동기 콘솔

console.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문이다. 이런 일들이 물밑에서 처리되고 있는 줄도 모르겠지만 페이지/UI 관점에서 보면 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 드물긴 하지만 이런 현상이 가끔가다 관찰되는 코드를 보자

```javascript
var a = {
    index: 1
};
console.log(a); // ???
a.index++;
```

console.log() 메서드가 실행되면 당연히 객체 스냅샷 {index: 1} 이 콘솔에 찍힌 다음 a.index++ 이 실핼될것이다. 그런데 간혹 브라우저가 콘솔 I/O 백그라운드 전환하는 것이 좋겠다고 결정하면 출력이 지연될 수 있다. 그래서 {index: 2} 로 나올때가 있다.

## 1.2 이벤트 루프

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 처리하는 실행기일 뿐이다.
자바스크립트 엔진은 혼자서는 못하고 반드시 호스팅(대표적으로 브라우저)에서 실행된다. 자바스크립트는 여러 환경이 있지만, 스레드는 항상 공통으로 여러 덩이를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 이벤트 루프라는 장치다 즉, 덩이를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경 몫이다.

콜백 함수를 예를 들면 이것은 마치 자바스크립트 엔진이 호스팅 환경에게 네트워크 요청이 끝나 결과 데이터가 만들어질때 다시 불러달라는 의미이다. 그 후 브라우저는 네트워크를 통해 리스닝하게 되고, 데이터가 도착하면 콜백함수를 이벤트 루프에 넣어 실행 스케줄링 한다.

다음은 이벤트 루프의 간단한 코드 형태이다 (실제로는 이렇게 되어있지는 않다)

```javascript
var eventLoop = [];
var event;
while (true) {
    // tick 발생
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
        event();
    }
}
```

반복문의 매 순회를 틱 이라고 하며 틱이 발생할때마다 큐에 적재된 이벤트를 꺼내어 실행하는 형태이다.

setTimeout 에 대해 다시 보면 이는 타이머를 설정해주는 함수로 타이머가 끝나면 환경에 콜백을 이벤트 루프에 삽입한 뒤 틱에서 실행하는 형태이다. 즉, 적어도 지정한 시간 이전에 콜백이 실행되지 않음을 보장할수는 있지만 정확한 타이밍으로 동작하지는 않는다.

## 1.3 병렬 스레딩

비동기는 앞서 말했듯이 '지금'과 '나중' 사이의 간극이고 병렬은 동시에 일어나는 일들과 연관된다.
프로세스와 스레드는 가장 많이 쓰는 병렬 컴퓨터 구조로 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유한다.

반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할수는 없다. 병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습이다.

병렬 실행 스레드 인터리빙과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위에서 일어난다.
예를 들어

```javascript
function later() {
    answer = answer * 2;
    console.log(answer)l
}
```

later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행하는 스레드애서는 여러 상이한 저수준의 작업들이 일어날수 있다. 예컨데 answer = asnwer * 2 는 현재 answer 조회 -> 곱셈 연산 수행 -> answer 변수에 저장

단일 스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 문제가 없다. 하지만 병렬 시스템은 다르다.

```javascript
var a = 20;
function foo() {
    a = a + 1;
}
function bar() {
    a = a * 2;
}
ajax('url', foo);
ajax('url2', bar);
```

자바스크립트는 단일 스레드 이므로 foo -> bar 이면 a 는 42, 반대이면 41 이 된다.

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡하다.
foo 메서드의 경우 a 조회 -> 더하기 연산 수행 -> a 저장의 프로세스를 거치고
bar 메서드의 경우 a 조회 -> 곱하기 연산 수행 -> a 저장의 프로세스를 거치는데 섞이게 되는경우 결과값을 예측할수 없게된다.

자바스크립트는 스레드 간의 데이터공유를 하지 않으므로 비결정성의 수즌은 문제가 되지않지만 위의 코드를 보면 항상 결정적일 수도 없다.

### 1.3.1 완전-실행

자바스크립트의 작동 모드는 단잉-스레드 이므로 내부 코드는 원자적이다. 즉, 함수 전체 코드가 끝나야 다른 함수가 실행된다는 뜻이다. 이를 완전-실행이라고 한다.
흔히 잦바스크립트에서 함수 순서에 따른 비결정성을 경합 조건이라고 하는데, 누가 먼저 실행되나 내기하는 경합같다는 의미에서이다.

## 1.4 동시성

스크롤바를 아래로 내리면 계속 리스트가 갱신되는 페이지를 만든다고 생각할때, 이런 기능은 적어도 2개의 분리된 로직을 동시에 실행할수 있어야 한다. 첫 로직는 스크롤 이벤트 발생, 두번째 로직는 네트워크 응답을 받고 그리는 작업이다.

동시성은 복수의 로직이 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다.

### 1.4.1 비상호 작용

복수의 로직이 이벤트를 동시에 인터리빙할때 서로가 상호작용이 일어나지않는다면 비결정성은 완벽하게 수용하능하다. 순서와도 상관없으니 언제나 결과를 예측할수 있다.

### 1.4.2 상호 작용

순서에 따라 결과에 달라지는 경우 상호 작용의 순서를 잘 조정해서 결과를 예측할수 있게 해주어야한다.
예를 들면 함수 호출에 관문을 두는 형태이다.

```javascript
var a, b;
function foo(x) {
    a = x * 2;
    baz()
};
function bar(y) {
    b = y * 2;
    baz();
};
function baz() {
    console.log(a + b);
}
ajax('url', foo);
ajax('url2', bar);
```

위 코드는 foo, bar 중 어느쪽이 먼저 실행하더라도 다른 하나는 결과값이 없는 상태니 문제가 된다.
이럴때 baz 함수 호출 조건에 (a && b) 등의 관문을 두면 비결정성을 어느정도 수용할수 있게 된다.

### 1.4.3 협동

협동적 동시성은 동시성을 조정하는 다른 방안으로 실행 시간이 오래 걸리는 로직을 여러 단계/배치로 쪼개어 다른 동시 로직이 각자 이벤트 루프 큐에 인터리빙 하도록 하는 게 목표이다.
간단한 예시를 보면

```javascript
var res = [];
function response(data){
    var chunk = data.splice(0, 1000);
    res = res.concat(chunk.map((val) => val * 2);
    if (data.length > 0) {
        setTimeout(() => response(data), 0);
    }
}
```

setTimeout(..., 0) 은 비동기 스케줄링의 스킬중 하나로 함수를 현재 이벤트 루프 큐의 맨 끝에 넣어주는 방법이다. 즉, 코드를 보면 한번에 처리되어야할 작업이 1000개씩 분리되어 현재 로직을 처리하고 남은 부분을 이벤트 루프 끝에 넣어서 처리하는 방식으로 하는 것이다.

## 1.5 잡

잡 큐는 ES6 부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 간단하게 설명하자면 잡 큐는 이벤트 루프 큐에서 매 틱의 끝자락에 매달려 있는 큐 라고 생각하면 좋다. 즉, 이벤트 루프 큐에 추가하는것이 아닌 현재 틱의 잡 큐 끝부분에 추가가 된다. 이건 마치 '나중'에 처리해야할 우선순위가 높은 작업이라고 할수 있다.

```javascript
console.log('A');
setTimeout(() => console.log('B'), 0);
schedule(() => { // 이론적인 API 라 가정
    console.log('C');
    schedule(() => console.log('D'));
})
```

위와 같은 코드가 있을때 A C D B 순서로 출력하게 된다.

## 1.6 문 순서

자바스크립트 엔진은 코드를 컴파일 하기 전에 문 수서를 재정렬 하여 실행 시간을 줄일 여지가 있는지 확인한다. 물론 최종 결과가 뒤바뀌지 않도록 안전하게 최적화 한다. 여기서 말하고자 하는 바는 소스 코드 순서(위 -> 아래)와 컴파일 후 실행순서는 사실상 아무 관련이 없다는 것이다.

## 2.0 콜백

함수 안의 문은 예측 가능한 순서대로 실행되지만 함수 단위의 실행 순서는 이벤트에 따라 달라질수 있다.
콜백은 큐에서 대기 중인 함수가 처리되자마자 본 프로그램으로 돌아올 목적지이다.
이는 자바스크립트 언어에서 가장 기본적인 비동기 패턴이다.

## 2.1 연속성

다음 간단한 콜백 예제를 보자

```javascript
// A
ajax('url', function() {
    // B
});
// C
```

A,C 는 비동기 '지금', B 는 '나중' 에 해당하는 코드가 된다. '지금'에 해당하는 부분이 실행되고 비결정적인 시간 동안 중지되었다가 ajax 호출이 끝날때 중지되기 이전 시점으로 돌아와 '나중' 부분이 실행된다. 다시 말해, 콜백은 프로그램의 연속성을 캡슐화한 장치이다.

## 2.2 두뇌는 순차적이다

사람은 기본적으로 싱글태스커에 가깝다. 동시에 일을 한다는 것은 재빠른 콘텍스트 교환기를 통해 행동하고 있을 뿐이다. 여기서 말하고 싶은점은 인간의 두뇌가 이벤트 루프 큐처럼 동작한다는 사실이다.

### 2.2.1 실행 vs 계획

두뇌는 이벤트 루프 큐처럼 동작한다고 했지만 사실은 그리 단순하지는 않다. 하루를 어떤 순서로 계획한다는것 자체가 이미 어긋나게 된다. 예를 들면 오늘 할 일을 이렇게 작성하지는 않을 것이다

"오늘 가게에 가서 우유를 가야겠다. 그런데 가능 도중에 친구에게 전화가 올 것이고, 나는 전화를 받으면서 인사를 하겠지. 그리고 눈 앞의 돌 다리를 하나씩 건너면서 ..."

이렇게 모든 일을 예측하면서 할 일을 계획할수는 없다. 이것이 비동기 코드 작성이 어려운 이유이다. 사람이 비동기 흐름을 생각하는 일 자체가 부담스럽기 때문이다.

### 2.2.2 중첩/연쇄된 콜백

```javascript
listen('click', function handler(evt) {
    setTimeout(function request() {
        ajax('url', function response(text) {
            // logic
        })
    })
})
```

이른바 이런 콜백 지옥 이라는 코드를 자주 보았을 것이다. 이는 단순히 가독성을 떠나서 심각한 문제를 가지고 있다. 차근차근 설명하면
우선 클릭 이벤트 대기 -> 타이머 작동까지 대기 -> ajax 응답 받을때 까지 대기 순으로 진행하고 이후 처음으로 되돌아온다. 이것의 문제점은
첫째, 위의 순서는 수 많은 경우의 수 중 하나의 실행에 불과하다는 것이다. 타이머 작동에 문제가 생길수도 있고, ajax 에 문제가 생길수도 있는것이다.
이번엔 다른 문제를 가지고 있는 코드를 보자

```javascript
doA(function() {
    doB();
    doC(function() {
        doD();
    })
    doE();
});
doF();
```

다음 코드 순서는 A - F - B - C - E - D 가 될것이다. 그런데 만약 doA 와 doC가 비동기 코드가 아니라면 어떻게 될까? 그럼 순서는 A - B - C - D - E - F 가 될것이다.
앞서 예시를 든 문제들에 대해 모든 경우의 수를 하드코딩한다면 이는 코드가 너무 복잡해져 수정이 난처하게 될것이다. 이것이 콜백의 첫번째 단점이다.

## 2.3 믿음성 문제

콜백의 가장 큰 문제점은 앞서 말한 콘텍스트 교환기 이다. 대부분의 콜백을 넘겨주는 함수는 서드 파티가 제공한 유탈리티의 경우가 대부분인데, 내가 작성하는 코드임에도 불구하고 서드 파티의 로직에 의존해야하는 제어의 역전이라는 상황에 마주하게 된다.

### 2.3.1 다섯 마리 콜백 이야기

이해를 돕기 위한 예를 하난 들어보자
당신은 전자상거래 결제 시스템을 구축하는 담당자라고 해보자. 그리고 실제 고객이 결재하는 부분은
다음과 같이 코드를 구성했다고 생각해보자

```javascript
analytics.trackPurchase(purchaseData, function() {
    chargeCreditCard();
    displayThankyouPage();
})
```

시간이 흘러 결제하는 부분에서 문제가 생겼다고 연락이 왔다. 문제 내용은 결제가 5번 이루어졌다는것이다.
로그를 분석해보니 결제를 하는 로직이 5번이나 실행이 된것이다. 콜백을 한번도 실행하지 않을 수도 있고, 일찍 호출하거나 늦게 호출할수도 있는것이다. 이럴때마다 우리가 경우의 수를 모두 따져서 코드를 작성하기란 힘든일이다. 이것이 콜백의 가장 큰 두번째 문제이다.

## 2.4 콜벡을 구하라

이러한 콜백의 문제를 해결하고자 에러를 처리하려고 분할 콜백 기능을 제공하는 API 가 있다.
또는 에러 우선 스타일 이라는 콜백 패턴 또한 많이 쓴다. 그러나 이것들도 반복적인 콜백 호출을 방지하거나 등 의 기능은 존재하지 않는다. 이러한 문제를 해결하기 위해 지금까지 개발자들은 오버헤드를 넣는 식으로 손수 장치를 마련해 왔다. 콜백을 한 번도 호출하지 않는다면 타임아웃을 걸어놓았다던가, 주어진 API 를 항상 예측 가능한 비동기 콜백으로 호출하든가의 유틸리티를 작성해왔다.

## 3.0 프라미스

이전 목차를 통해서 콜백을 통한 비동기성은 순차성과 믿음성이 결함이 있음을 알았다. 이제 해결책을 알아보자
먼저, 제어의 역전 - 믿음의 문제부터 해결하자
프로그램의 진행을 다른 파트로 넘기지 않고 개발자가 언제 작업을 끝낼지 알고, 그 다음에 무슨일을하지 결정할수 있으면 될것이다. 이러한 체계가 프라미스 이다.

## 3.1 프라미스란

개발자들은 본능적으로 코드로 새로운 기술/패턴을 익히는 경향이 있다. 하지만 API 만으로는 그 이면의 추상화를 파악하기가 어렵다. 프라미스는 제대로 알고 써야 극적으로 달라지는것을 느끼게 해주는 도구이다.
코드를 보여주기 전 개념을 충분히 설명하고 정리할수 있게 안내하도록 하겠다.

### 3.1.1 미랫값

햄버거 가게에서 치즈 버거 세트를 주문했다고 생각해보자. 그럼 카운터 점원은 돈을 받고 영수증 번호(미랫값)를 준다. 후에 치즈 버거 세트가 나오면 영수증 세트와 교환하고 치즈 버거 세트를 받는다.
여기서 미랫값이 준비된 값-프라미스를 교환한 셈이다. 또는 이런 상황도 생길수도 있다. 주문 번호를 받고 달려갔지만, 재료가 떨어져서 치즈 버거 세트를 못받는 경우도 있다. 미랫값은 성공 아니면 실패라는 결과를 가진다.

#### 3.1.1.1 지금값과 나중값

좀 더 구체적으로 이야기해보자. 프라미스 작동 원리를 소개하기 전에 콜백이야기부터 시작해보자.
숫자 계산 등 어떤 값을 내는 코드를 짤 때 우리는 '지금' 존재하는 구체적인 값이라는 근원적인 가정을 한다. 이를테면 x+y 연산을 할때 두 값은 이미 세팅된 값이라고 본다. 이는 x, y 값이 귀결(resolved) 됬다고 말한다. + 연산자가 x, y 값을 감지하다가 두 값이 귀결될때 덧셈을 해주면 좋겠지만 프로그램에 상당하 혼란이 올수도 있다.
다음 코드를 보자

```javascript
function add(getX, getY, cb) {
    var x, y;
    getX((xVal) => {
        x = xVal;
        if (y != undefined) {
            cb(x + y);
        }
    });
    getY((yVal) => {
        y = yVal;
        if (x != undefined) {
            cb(x + y);
        }
    });
}
add(fetchX, fetchY, (sum) => {
    console.log(sum);
})
```

코드가 더럽지만 이런 패턴은 중요한 메세지를 담고 있다. 바로 x, y 를 미랫값으로 취급한다는 것이다.
add() 함수 입장에서 x 또는 y 의 값이 지금 준비된 상태인지는 관심 밖이다. 디시 말해 '지금' 과 '나중' 을 정규화한 결과 처리 결과를 예측할수 있게 된것이다. 요점을 말하면 '지금'과 '나중'을 모두 일관적으로 다루려면 둘 다 '나중'으로 만들어 모든 작업을 비동기화 하면 된다.

#### 3.1.1.2 프라미스 값

이번에는 x + y 를 프라미스 함수로 나타내보겠다

```javascript
function add(xPromise, yPromise) {
    // Promise.all([]) 은 프라미스 배열을 인자로 받아 모두 귀결될때 까지 기다렸다가
    // 새 프라미스를 만들어 반환하는 함수다.
    return Promise.all([xPromise, yPromise])
        .then((values) => {
            // values 는 앞에서 귀결된 프라미스가 건네준 메시지 배열이다.
            return values[0] + values[1];
        });
}

// fetchX, fetchY 는 제각기 값을 가진 프라미스를 반환하는데 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
    .then((sum) => {
        console.log(sum);
    });
```

이 예제에는 두 계층의 프라미스가 있다. fetchX, fetchY 를 직접 호출하여 이들의 반환값 프라미스를 add 에 전한다. 두 프라미스 속의 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프라미스가 같은 결과를 내게끔 정규화 한다. 덕분에 미랫값 X, Y는 시간에 독립적으로 추론할 수 있다.

두번째 계층은 add 가 만들어 반환한 프라미스로 then() 을 호출하고 대기한다.
add 가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력된다.

치즈버거 세트처럼 프라미스는 이룸(fullfillment) 아닌 버림(rejection) 으로 귀결될수 있다.
항상 귀결값을 프로그램이 결정짓는 이룸 프라미스와 다르게 버림값은 프로그램 로직에 직접 세팅하거나 런타임 예외에 의해 암시적으로 생겨난다.
프라미스 then() 함수는 이룸 함수를 첫번째 인자로, 버림함수를 두번째 인자로 각각 넘겨받는다.

```javascript
add(fetchX(), fetchY())
    .then((value) => {
        // fullfillment
    }, (err) => {
        // rejection
    });
```

X, Y 조회 시 문제가 있거나 뎃셈 연산이 실패하면 add() 가 반환하는 프라미스는 버려지고 then() 의 두 번째 에러 처리 콜백이 이 프라미스에서 버림값을 받는다.

프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이고 내부 결과값에 상관없이 예측 가능한 방향으로 구성할 수 있다. 또한 프라미스는 귀결된 후에는 그 상태가 유지(불변)되며 몆번이든 꺼내 쓸 수 있다. 프라미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치다.

### 3.1.2 완료 이벤트

프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 흐름 제어하기 위한 체계라 볼 수 있다.

어떤 작업을 하려고 foo() 함수를 부른다 치자. 내용은 알필요없고 다음 단계로 넘어가는 시점만 알수있으면 된다. 다시 마랗면 다음 단계로 진행할수 있게끔 완료 상태를 알림 받을 방법이 있으면 좋을것 같다. 자바스크립트는 알림 자체를 하나의 이벤트로 보고 리스닝한다. foo() 의 완료 이벤트를 리스닝 함으로써 알림 요건을 재구성하는 것이다.

콜백에서의 알림은 메소드를 넘겨서 구성했지만 프라미스는 제어의 역전이 역전되어 foo() 에서 이벤트를 리스닝하고 있다가 알림은 받게 되면 다음으로 진행한다

```javascript
foo() {
    // somthing
}
on (foo 'complete') {
    // somthing
}
on (foo 'fail') {
    // somthing
}
```

위 의사코드를 보면 foo() 메서드에 이벤트 리스너를 설정한다. foo() 의 결과는 완료 아니면 실패이다.
foo() 는 호출부에서 이벤트를 받아 어떻게 처리할지 알 길이 없으니 아주 멋지게 관심사가 분리된다.

아쉽게도 자바스크립트는 이런 문법이 없다. 자연스러운 코드는 다음과 같이 표현이 된다.

```javascript
function foo(x) {
    // somthing
    // 이벤트 구독기를 생성하여 발행한다.
    return listener;
}
var evt = foo(42);
evt.on('completion', function() {
    // next
});
evt.on('failure', function() {
    // error
});
```

foo() 는 이벤트 구독기를 생성하여 반환하도록 명시되어 있고, 이는 두 이벤트 처리기를 각각 등록한다.
콜백 지향 코드와 정 반대로 foo() 에 콜밷 함수를 넘겨주는 대신 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣어주는 것이다.

#### 3.1.2.1 프라미스 '이벤트'

이 evt 이벤트 구독기가 프라미스와 유사하다. 프라미스 식으로 앞 예제를 다루면 foo()는 프리미스 인스턴스를 생성하여 반환하고 이 프라미스를 리스닝하는 함수에 전해주면 된다.

```javascript
function foo(x) {
    // somthing
    return new Promise(function(resolve, reject) {
        // resolve, reject 중 한쪽을 호출하고 이들은 프라미스의 귀결 콜백 함수역활을 한다.
        // 생성자 노출 패턴의 모습으로 전달된 function 은 지연없이 바로 실행되고
        // resolve, reject 라고 이름 붙은 2개의 인자를 받는데 이게 프라미스의 귀결 함수이다.
    });
}

var p = foo(42);
bar(p);
baz(p);

function bar(fooPromise) {
    fooPromise.then(() => {}, () => {});
}   // baz 도 비슷한 형태
```

또는 단지 흐름 제어 신로로써 쓰일수도 있다

```javascript
function bar() {
    // foo 작업이 끝났으므로
    // bar 작업을 시작한다.
}

function oopsBar() {
    // foo 작업에 문제가 생겨서
    // bar 작업은 실행되지 않는다.
}

var p = foo(42);
p.then(bar, oopsBar);
// baz 도 똑같다.
```

앞의 예제와 뒤의 예제의 가장 큰 차이점은 에러 처리 방식이다. 전자는 foo() 의 이룸/버림 여부와 상관없이 무조건 bar() 를 호출하고 foo 실행이 실패할 경우엔 자체 로직이 처리한다.
반면 후자는 foo() 성공시에만 bar 를 호출하고 그 외의 경우 oopsBar 를 호출한다.

또한 then() 을 두 번 호추랗는 부분에서 프라미스는 일단 귀결이 되면 똑같은 결과를 유지하므로 몆번이고 계속 꺼내 쓸 수 있다.

## 3.2 데너블 덕 타이핑
