# 1. 객체

**이 글은 You Don't Know JS을 참고해서 쓴 글입니다.**

## 1.0. 개요

자바스크립트의 비동기성에서 가장 중요한 부분은 지금 실행하는 부분과 나중에 실행하는 부분의 간극이다.
이러한 간극은 입력 대기, DB/File 시스템 조회, 네트워크를 경유한 데이터 송신 후 응답, 일정한 시간동안 반복적인 작업(-애니메이션) 등이 있다.

## 1.1 프로그램 덩이

자바스크립트 프로그램은 여러 개의 덩이(Chunk) 로 구성되며, 지금 실행중인 덩이 하나와 나중에 실행할 덩이 들로 구성하게 된다. 여기서 주의할점은 '지금' 의 다음은 '나중' 이 아니다.
대표적인 예시로 네트워크 통신을 보자

```javascript
const { data } = ajax('url');
console.log(data); // undefined
```

표준 ajax 요청은 동기적으로 작동하지 않아서 함수 결과값을 변수에 담기전에 '지금' 실행하는 부분이 작동한다. '지금'부터 '나중'까지 기다리는 가장 간단한 방법으로 콜백 함수를 사용할수 있다.

```javascript
ajax('url', ( data ) => { console.log(data) }); // response
```

또는 동기적인 네트워크 방식을 사용할수도 있지만 이는 UI 를 마비시키므로 논점에서 제외하겠다.

다음은 간단한 자바스크립트 코드이다

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log(answer);
}

var answer = now();
setTimeout( later, 1000 ); // 1초 후에 later 메소드를 실행하겠다.
```

이 코드는 '지금' 과 '나중' 이라는 두 덩이로 이루어진 코드이다.
프로그램을 시작하면 '지금' 이라는 덩이가 바로 실행이 되고 '나중' 이벤트를 설정하는 setTimeout 에 의해 '나중' 덩이가 실행된다.

### 1.1.1 비동기 콘솔

console.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문이다. 이런 일들이 물밑에서 처리되고 있는 줄도 모르겠지만 페이지/UI 관점에서 보면 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 드물긴 하지만 이런 현상이 가끔가다 관찰되는 코드를 보자

```javascript
var a = {
    index: 1
};
console.log(a); // ???
a.index++;
```

console.log() 메서드가 실행되면 당연히 객체 스냅샷 {index: 1} 이 콘솔에 찍힌 다음 a.index++ 이 실핼될것이다. 그런데 간혹 브라우저가 콘솔 I/O 백그라운드 전환하는 것이 좋겠다고 결정하면 출력이 지연될 수 있다. 그래서 {index: 2} 로 나올때가 있다.

## 1.2 이벤트 루프

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 처리하는 실행기일 뿐이다.
자바스크립트 엔진은 혼자서는 못하고 반드시 호스팅(대표적으로 브라우저)에서 실행된다. 자바스크립트는 여러 환경이 있지만, 스레드는 항상 공통으로 여러 덩이를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 이벤트 루프라는 장치다 즉, 덩이를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경 몫이다.

콜백 함수를 예를 들면 이것은 마치 자바스크립트 엔진이 호스팅 환경에게 네트워크 요청이 끝나 결과 데이터가 만들어질때 다시 불러달라는 의미이다. 그 후 브라우저는 네트워크를 통해 리스닝하게 되고, 데이터가 도착하면 콜백함수를 이벤트 루프에 넣어 실행 스케줄링 한다.

다음은 이벤트 루프의 간단한 코드 형태이다 (실제로는 이렇게 되어있지는 않다)

```javascript
var eventLoop = [];
var event;
while (true) {
    // tick 발생
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
        event();
    }
}
```

반복문의 매 순회를 틱 이라고 하며 틱이 발생할때마다 큐에 적재된 이벤트를 꺼내어 실행하는 형태이다.

setTimeout 에 대해 다시 보면 이는 타이머를 설정해주는 함수로 타이머가 끝나면 환경에 콜백을 이벤트 루프에 삽입한 뒤 틱에서 실행하는 형태이다. 즉, 적어도 지정한 시간 이전에 콜백이 실행되지 않음을 보장할수는 있지만 정확한 타이밍으로 동작하지는 않는다.

## 1.3 병렬 스레딩


