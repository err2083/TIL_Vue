# 1. 비동기

**이 글은 You Don't Know JS을 참고해서 쓴 글입니다.**

## 1.0. 지금과 나중

자바스크립트의 비동기성에서 가장 중요한 부분은 지금 실행하는 부분과 나중에 실행하는 부분의 간극이다.
이러한 간극은 입력 대기, DB/File 시스템 조회, 네트워크를 경유한 데이터 송신 후 응답, 일정한 시간동안 반복적인 작업(-애니메이션) 등이 있다.

## 1.1 프로그램 덩이

자바스크립트 프로그램은 여러 개의 덩이(Chunk) 로 구성되며, 지금 실행중인 덩이 하나와 나중에 실행할 덩이 들로 구성하게 된다. 여기서 주의할점은 '지금' 의 다음은 '나중' 이 아니다.
대표적인 예시로 네트워크 통신을 보자

```javascript
const { data } = ajax('url');
console.log(data); // undefined
```

표준 ajax 요청은 동기적으로 작동하지 않아서 함수 결과값을 변수에 담기전에 '지금' 실행하는 부분이 작동한다. '지금'부터 '나중'까지 기다리는 가장 간단한 방법으로 콜백 함수를 사용할수 있다.

```javascript
ajax('url', ( data ) => { console.log(data) }); // response
```

또는 동기적인 네트워크 방식을 사용할수도 있지만 이는 UI 를 마비시키므로 논점에서 제외하겠다.

다음은 간단한 자바스크립트 코드이다

```javascript
function now() {
    return 21;
}

function later() {
    answer = answer * 2;
    console.log(answer);
}

var answer = now();
setTimeout( later, 1000 ); // 1초 후에 later 메소드를 실행하겠다.
```

이 코드는 '지금' 과 '나중' 이라는 두 덩이로 이루어진 코드이다.
프로그램을 시작하면 '지금' 이라는 덩이가 바로 실행이 되고 '나중' 이벤트를 설정하는 setTimeout 에 의해 '나중' 덩이가 실행된다.

### 1.1.1 비동기 콘솔

console.log() 메서드는 브라우저 유형과 상황에 따라 출력할 데이터가 마련된 직후에도 콘솔창에 바로 표시되지 않을 수 있다. 많은 프로그램에서 I/O 부분이 가장 느리고 중단이 잦기 때문이다. 이런 일들이 물밑에서 처리되고 있는 줄도 모르겠지만 페이지/UI 관점에서 보면 브라우저가 콘솔 I/O를 백그라운드에서 비동기적으로 처리해야 성능상 유리하다. 드물긴 하지만 이런 현상이 가끔가다 관찰되는 코드를 보자

```javascript
var a = {
    index: 1
};
console.log(a); // ???
a.index++;
```

console.log() 메서드가 실행되면 당연히 객체 스냅샷 {index: 1} 이 콘솔에 찍힌 다음 a.index++ 이 실핼될것이다. 그런데 간혹 브라우저가 콘솔 I/O 백그라운드 전환하는 것이 좋겠다고 결정하면 출력이 지연될 수 있다. 그래서 {index: 2} 로 나올때가 있다.

## 1.2 이벤트 루프

자바스크립트 엔진은 요청하면 프로그램을 주어진 시점에 한 덩이씩 처리하는 실행기일 뿐이다.
자바스크립트 엔진은 혼자서는 못하고 반드시 호스팅(대표적으로 브라우저)에서 실행된다. 자바스크립트는 여러 환경이 있지만, 스레드는 항상 공통으로 여러 덩이를 시간에 따라 매 순간 한번씩 엔진을 실행시키는 이벤트 루프라는 장치다 즉, 덩이를 스케줄링하는 일은 엔진을 감싸고 있는 주위 환경 몫이다.

콜백 함수를 예를 들면 이것은 마치 자바스크립트 엔진이 호스팅 환경에게 네트워크 요청이 끝나 결과 데이터가 만들어질때 다시 불러달라는 의미이다. 그 후 브라우저는 네트워크를 통해 리스닝하게 되고, 데이터가 도착하면 콜백함수를 이벤트 루프에 넣어 실행 스케줄링 한다.

다음은 이벤트 루프의 간단한 코드 형태이다 (실제로는 이렇게 되어있지는 않다)

```javascript
var eventLoop = [];
var event;
while (true) {
    // tick 발생
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
        event();
    }
}
```

반복문의 매 순회를 틱 이라고 하며 틱이 발생할때마다 큐에 적재된 이벤트를 꺼내어 실행하는 형태이다.

setTimeout 에 대해 다시 보면 이는 타이머를 설정해주는 함수로 타이머가 끝나면 환경에 콜백을 이벤트 루프에 삽입한 뒤 틱에서 실행하는 형태이다. 즉, 적어도 지정한 시간 이전에 콜백이 실행되지 않음을 보장할수는 있지만 정확한 타이밍으로 동작하지는 않는다.

## 1.3 병렬 스레딩

비동기는 앞서 말했듯이 '지금'과 '나중' 사이의 간극이고 병렬은 동시에 일어나는 일들과 연관된다.
프로세스와 스레드는 가장 많이 쓰는 병렬 컴퓨터 구조로 별개의 프로세서, 심지어는 물리적으로 분리된 컴퓨터에서도 독립적으로 실행되며 여러 스레드는 하나의 프로세스 메모리를 공유한다.

반면 이벤트 루프는 작업 단위로 나누어 차례대로 실행하지만 공유 메모리에 병렬로 접근하거나 변경할수는 없다. 병렬성과 직렬성이 나뉜 스레드에서 이벤트 루프를 협동하는 형태로 공존하는 모습이다.

병렬 실행 스레드 인터리빙과 비동기 이벤트 인터리빙은 완전히 다른 수준의 단위에서 일어난다.
예를 들어

```javascript
function later() {
    answer = answer * 2;
    console.log(answer)l
}
```

later() 함수 전체 내용은 이벤트 루프 큐가 하나의 원소로 취급하므로 이 함수를 실행하는 스레드애서는 여러 상이한 저수준의 작업들이 일어날수 있다. 예컨데 answer = asnwer * 2 는 현재 answer 조회 -> 곱셈 연산 수행 -> answer 변수에 저장

단일 스레드 환경에서는 스레드 간섭은 일어나지 않으므로 스레드 큐에 저수준 작업의 원소가 쌓여 있어도 문제가 없다. 하지만 병렬 시스템은 다르다.

```javascript
var a = 20;
function foo() {
    a = a + 1;
}
function bar() {
    a = a * 2;
}
ajax('url', foo);
ajax('url2', bar);
```

자바스크립트는 단일 스레드 이므로 foo -> bar 이면 a 는 42, 반대이면 41 이 된다.

같은 데이터를 공유하는 자바스크립트 이벤트의 병렬 실행 문제는 더 복잡하다.
foo 메서드의 경우 a 조회 -> 더하기 연산 수행 -> a 저장의 프로세스를 거치고
bar 메서드의 경우 a 조회 -> 곱하기 연산 수행 -> a 저장의 프로세스를 거치는데 섞이게 되는경우 결과값을 예측할수 없게된다.

자바스크립트는 스레드 간의 데이터공유를 하지 않으므로 비결정성의 수즌은 문제가 되지않지만 위의 코드를 보면 항상 결정적일 수도 없다.

### 1.3.1 완전-실행

자바스크립트의 작동 모드는 단잉-스레드 이므로 내부 코드는 원자적이다. 즉, 함수 전체 코드가 끝나야 다른 함수가 실행된다는 뜻이다. 이를 완전-실행이라고 한다.
흔히 잦바스크립트에서 함수 순서에 따른 비결정성을 경합 조건이라고 하는데, 누가 먼저 실행되나 내기하는 경합같다는 의미에서이다.

## 1.4 동시성

스크롤바를 아래로 내리면 계속 리스트가 갱신되는 페이지를 만든다고 생각할때, 이런 기능은 적어도 2개의 분리된 로직을 동시에 실행할수 있어야 한다. 첫 로직는 스크롤 이벤트 발생, 두번째 로직는 네트워크 응답을 받고 그리는 작업이다.

동시성은 복수의 로직이 같은 시간 동안 동시에 실행됨을 의미하며, 각 프로세스 작업들이 병렬로 처리되는지와는 관계없다.

### 1.4.1 비상호 작용

복수의 로직이 이벤트를 동시에 인터리빙할때 서로가 상호작용이 일어나지않는다면 비결정성은 완벽하게 수용하능하다. 순서와도 상관없으니 언제나 결과를 예측할수 있다.

### 1.4.2 상호 작용

순서에 따라 결과에 달라지는 경우 상호 작용의 순서를 잘 조정해서 결과를 예측할수 있게 해주어야한다.
예를 들면 함수 호출에 관문을 두는 형태이다.

```javascript
var a, b;
function foo(x) {
    a = x * 2;
    baz()
};
function bar(y) {
    b = y * 2;
    baz();
};
function baz() {
    console.log(a + b);
}
ajax('url', foo);
ajax('url2', bar);
```

위 코드는 foo, bar 중 어느쪽이 먼저 실행하더라도 다른 하나는 결과값이 없는 상태니 문제가 된다.
이럴때 baz 함수 호출 조건에 (a && b) 등의 관문을 두면 비결정성을 어느정도 수용할수 있게 된다.

### 1.4.3 협동

협동적 동시성은 동시성을 조정하는 다른 방안으로 실행 시간이 오래 걸리는 로직을 여러 단계/배치로 쪼개어 다른 동시 로직이 각자 이벤트 루프 큐에 인터리빙 하도록 하는 게 목표이다.
간단한 예시를 보면

```javascript
var res = [];
function response(data){
    var chunk = data.splice(0, 1000);
    res = res.concat(chunk.map((val) => val * 2);
    if (data.length > 0) {
        setTimeout(() => response(data), 0);
    }
}
```

setTimeout(..., 0) 은 비동기 스케줄링의 스킬중 하나로 함수를 현재 이벤트 루프 큐의 맨 끝에 넣어주는 방법이다. 즉, 코드를 보면 한번에 처리되어야할 작업이 1000개씩 분리되어 현재 로직을 처리하고 남은 부분을 이벤트 루프 끝에 넣어서 처리하는 방식으로 하는 것이다.

## 1.5 잡

잡 큐는 ES6 부터 이벤트 루프 큐에 새롭게 도입된 개념이다. 간단하게 설명하자면 잡 큐는 이벤트 루프 큐에서 매 틱의 끝자락에 매달려 있는 큐 라고 생각하면 좋다. 즉, 이벤트 루프 큐에 추가하는것이 아닌 현재 틱의 잡 큐 끝부분에 추가가 된다. 이건 마치 '나중'에 처리해야할 우선순위가 높은 작업이라고 할수 있다.

```javascript
console.log('A');
setTimeout(() => console.log('B'), 0);
schedule(() => { // 이론적인 API 라 가정
    console.log('C');
    schedule(() => console.log('D'));
})
```

위와 같은 코드가 있을때 A C D B 순서로 출력하게 된다.

## 1.6 문 순서

자바스크립트 엔진은 코드를 컴파일 하기 전에 문 수서를 재정렬 하여 실행 시간을 줄일 여지가 있는지 확인한다. 물론 최종 결과가 뒤바뀌지 않도록 안전하게 최적화 한다. 여기서 말하고자 하는 바는 소스 코드 순서(위 -> 아래)와 컴파일 후 실행순서는 사실상 아무 관련이 없다는 것이다.

## 2.0 콜백

함수 안의 문은 예측 가능한 순서대로 실행되지만 함수 단위의 실행 순서는 이벤트에 따라 달라질수 있다.
콜백은 큐에서 대기 중인 함수가 처리되자마자 본 프로그램으로 돌아올 목적지이다.
이는 자바스크립트 언어에서 가장 기본적인 비동기 패턴이다.

## 2.1 연속성

다음 간단한 콜백 예제를 보자

```javascript
// A
ajax('url', function() {
    // B
});
// C
```

A,C 는 비동기 '지금', B 는 '나중' 에 해당하는 코드가 된다. '지금'에 해당하는 부분이 실행되고 비결정적인 시간 동안 중지되었다가 ajax 호출이 끝날때 중지되기 이전 시점으로 돌아와 '나중' 부분이 실행된다. 다시 말해, 콜백은 프로그램의 연속성을 캡슐화한 장치이다.

## 2.2 두뇌는 순차적이다

사람은 기본적으로 싱글태스커에 가깝다. 동시에 일을 한다는 것은 재빠른 콘텍스트 교환기를 통해 행동하고 있을 뿐이다. 여기서 말하고 싶은점은 인간의 두뇌가 이벤트 루프 큐처럼 동작한다는 사실이다.

### 2.2.1 실행 vs 계획

두뇌는 이벤트 루프 큐처럼 동작한다고 했지만 사실은 그리 단순하지는 않다. 하루를 어떤 순서로 계획한다는것 자체가 이미 어긋나게 된다. 예를 들면 오늘 할 일을 이렇게 작성하지는 않을 것이다

"오늘 가게에 가서 우유를 가야겠다. 그런데 가능 도중에 친구에게 전화가 올 것이고, 나는 전화를 받으면서 인사를 하겠지. 그리고 눈 앞의 돌 다리를 하나씩 건너면서 ..."

이렇게 모든 일을 예측하면서 할 일을 계획할수는 없다. 이것이 비동기 코드 작성이 어려운 이유이다. 사람이 비동기 흐름을 생각하는 일 자체가 부담스럽기 때문이다.

### 2.2.2 중첩/연쇄된 콜백

```javascript
listen('click', function handler(evt) {
    setTimeout(function request() {
        ajax('url', function response(text) {
            // logic
        })
    })
})
```

이른바 이런 콜백 지옥 이라는 코드를 자주 보았을 것이다. 이는 단순히 가독성을 떠나서 심각한 문제를 가지고 있다. 차근차근 설명하면
우선 클릭 이벤트 대기 -> 타이머 작동까지 대기 -> ajax 응답 받을때 까지 대기 순으로 진행하고 이후 처음으로 되돌아온다. 이것의 문제점은
첫째, 위의 순서는 수 많은 경우의 수 중 하나의 실행에 불과하다는 것이다. 타이머 작동에 문제가 생길수도 있고, ajax 에 문제가 생길수도 있는것이다.
이번엔 다른 문제를 가지고 있는 코드를 보자

```javascript
doA(function() {
    doB();
    doC(function() {
        doD();
    })
    doE();
});
doF();
```

다음 코드 순서는 A - F - B - C - E - D 가 될것이다. 그런데 만약 doA 와 doC가 비동기 코드가 아니라면 어떻게 될까? 그럼 순서는 A - B - C - D - E - F 가 될것이다.
앞서 예시를 든 문제들에 대해 모든 경우의 수를 하드코딩한다면 이는 코드가 너무 복잡해져 수정이 난처하게 될것이다. 이것이 콜백의 첫번째 단점이다.

## 2.3 믿음성 문제

콜백의 가장 큰 문제점은 앞서 말한 콘텍스트 교환기 이다. 대부분의 콜백을 넘겨주는 함수는 서드 파티가 제공한 유탈리티의 경우가 대부분인데, 내가 작성하는 코드임에도 불구하고 서드 파티의 로직에 의존해야하는 제어의 역전이라는 상황에 마주하게 된다.

### 2.3.1 다섯 마리 콜백 이야기

이해를 돕기 위한 예를 하난 들어보자
당신은 전자상거래 결제 시스템을 구축하는 담당자라고 해보자. 그리고 실제 고객이 결재하는 부분은
다음과 같이 코드를 구성했다고 생각해보자

```javascript
analytics.trackPurchase(purchaseData, function() {
    chargeCreditCard();
    displayThankyouPage();
})
```

시간이 흘러 결제하는 부분에서 문제가 생겼다고 연락이 왔다. 문제 내용은 결제가 5번 이루어졌다는것이다.
로그를 분석해보니 결제를 하는 로직이 5번이나 실행이 된것이다. 콜백을 한번도 실행하지 않을 수도 있고, 일찍 호출하거나 늦게 호출할수도 있는것이다. 이럴때마다 우리가 경우의 수를 모두 따져서 코드를 작성하기란 힘든일이다. 이것이 콜백의 가장 큰 두번째 문제이다.

## 2.4 콜벡을 구하라

이러한 콜백의 문제를 해결하고자 에러를 처리하려고 분할 콜백 기능을 제공하는 API 가 있다.
또는 에러 우선 스타일 이라는 콜백 패턴 또한 많이 쓴다. 그러나 이것들도 반복적인 콜백 호출을 방지하거나 등 의 기능은 존재하지 않는다. 이러한 문제를 해결하기 위해 지금까지 개발자들은 오버헤드를 넣는 식으로 손수 장치를 마련해 왔다. 콜백을 한 번도 호출하지 않는다면 타임아웃을 걸어놓았다던가, 주어진 API 를 항상 예측 가능한 비동기 콜백으로 호출하든가의 유틸리티를 작성해왔다.

## 3.0 프라미스

이전 목차를 통해서 콜백을 통한 비동기성은 순차성과 믿음성이 결함이 있음을 알았다. 이제 해결책을 알아보자
먼저, 제어의 역전 - 믿음의 문제부터 해결하자
프로그램의 진행을 다른 파트로 넘기지 않고 개발자가 언제 작업을 끝낼지 알고, 그 다음에 무슨일을하지 결정할수 있으면 될것이다. 이러한 체계가 프라미스 이다.

## 3.1 프라미스란

개발자들은 본능적으로 코드로 새로운 기술/패턴을 익히는 경향이 있다. 하지만 API 만으로는 그 이면의 추상화를 파악하기가 어렵다. 프라미스는 제대로 알고 써야 극적으로 달라지는것을 느끼게 해주는 도구이다.
코드를 보여주기 전 개념을 충분히 설명하고 정리할수 있게 안내하도록 하겠다.

### 3.1.1 미랫값

햄버거 가게에서 치즈 버거 세트를 주문했다고 생각해보자. 그럼 카운터 점원은 돈을 받고 영수증 번호(미랫값)를 준다. 후에 치즈 버거 세트가 나오면 영수증 세트와 교환하고 치즈 버거 세트를 받는다.
여기서 미랫값이 준비된 값-프라미스를 교환한 셈이다. 또는 이런 상황도 생길수도 있다. 주문 번호를 받고 달려갔지만, 재료가 떨어져서 치즈 버거 세트를 못받는 경우도 있다. 미랫값은 성공 아니면 실패라는 결과를 가진다.

#### 3.1.1.1 지금값과 나중값

좀 더 구체적으로 이야기해보자. 프라미스 작동 원리를 소개하기 전에 콜백이야기부터 시작해보자.
숫자 계산 등 어떤 값을 내는 코드를 짤 때 우리는 '지금' 존재하는 구체적인 값이라는 근원적인 가정을 한다. 이를테면 x+y 연산을 할때 두 값은 이미 세팅된 값이라고 본다. 이는 x, y 값이 귀결(resolved) 됬다고 말한다. + 연산자가 x, y 값을 감지하다가 두 값이 귀결될때 덧셈을 해주면 좋겠지만 프로그램에 상당하 혼란이 올수도 있다.
다음 코드를 보자

```javascript
function add(getX, getY, cb) {
    var x, y;
    getX((xVal) => {
        x = xVal;
        if (y != undefined) {
            cb(x + y);
        }
    });
    getY((yVal) => {
        y = yVal;
        if (x != undefined) {
            cb(x + y);
        }
    });
}
add(fetchX, fetchY, (sum) => {
    console.log(sum);
})
```

코드가 더럽지만 이런 패턴은 중요한 메세지를 담고 있다. 바로 x, y 를 미랫값으로 취급한다는 것이다.
add() 함수 입장에서 x 또는 y 의 값이 지금 준비된 상태인지는 관심 밖이다. 디시 말해 '지금' 과 '나중' 을 정규화한 결과 처리 결과를 예측할수 있게 된것이다. 요점을 말하면 '지금'과 '나중'을 모두 일관적으로 다루려면 둘 다 '나중'으로 만들어 모든 작업을 비동기화 하면 된다.

#### 3.1.1.2 프라미스 값

이번에는 x + y 를 프라미스 함수로 나타내보겠다

```javascript
function add(xPromise, yPromise) {
    // Promise.all([]) 은 프라미스 배열을 인자로 받아 모두 귀결될때 까지 기다렸다가
    // 새 프라미스를 만들어 반환하는 함수다.
    return Promise.all([xPromise, yPromise])
        .then((values) => {
            // values 는 앞에서 귀결된 프라미스가 건네준 메시지 배열이다.
            return values[0] + values[1];
        });
}

// fetchX, fetchY 는 제각기 값을 가진 프라미스를 반환하는데 지금 또는 나중에 준비된다.
add(fetchX(), fetchY())
    .then((sum) => {
        console.log(sum);
    });
```

이 예제에는 두 계층의 프라미스가 있다. fetchX, fetchY 를 직접 호출하여 이들의 반환값 프라미스를 add 에 전한다. 두 프라미스 속의 값은 지금 또는 나중에 준비되겠지만 시점에 상관없이 각 프라미스가 같은 결과를 내게끔 정규화 한다. 덕분에 미랫값 X, Y는 시간에 독립적으로 추론할 수 있다.

두번째 계층은 add 가 만들어 반환한 프라미스로 then() 을 호출하고 대기한다.
add 가 끝나면 덧셈을 마친 미랫값이 준비되어 콘솔에 출력된다.

치즈버거 세트처럼 프라미스는 이룸(fullfillment) 아닌 버림(rejection) 으로 귀결될수 있다.
항상 귀결값을 프로그램이 결정짓는 이룸 프라미스와 다르게 버림값은 프로그램 로직에 직접 세팅하거나 런타임 예외에 의해 암시적으로 생겨난다.
프라미스 then() 함수는 이룸 함수를 첫번째 인자로, 버림함수를 두번째 인자로 각각 넘겨받는다.

```javascript
add(fetchX(), fetchY())
    .then((value) => {
        // fullfillment
    }, (err) => {
        // rejection
    });
```

X, Y 조회 시 문제가 있거나 뎃셈 연산이 실패하면 add() 가 반환하는 프라미스는 버려지고 then() 의 두 번째 에러 처리 콜백이 이 프라미스에서 버림값을 받는다.

프라미스는 시간 의존적인 상태를 외부로부터 캡슐화하기 때문에 프라미스 자체는 시간 독립적이고 내부 결과값에 상관없이 예측 가능한 방향으로 구성할 수 있다. 또한 프라미스는 귀결된 후에는 그 상태가 유지(불변)되며 몆번이든 꺼내 쓸 수 있다. 프라미스는 미랫값을 캡슐화하고 조합할 수 있게 해주는 손쉬운 반복 장치다.

### 3.1.2 완료 이벤트

프라미스 각각은 미랫값으로서 작동하지만 프라미스의 귀결은 비동기 작업의 여러 단계를 흐름 제어하기 위한 체계라 볼 수 있다.

어떤 작업을 하려고 foo() 함수를 부른다 치자. 내용은 알필요없고 다음 단계로 넘어가는 시점만 알수있으면 된다. 다시 마랗면 다음 단계로 진행할수 있게끔 완료 상태를 알림 받을 방법이 있으면 좋을것 같다. 자바스크립트는 알림 자체를 하나의 이벤트로 보고 리스닝한다. foo() 의 완료 이벤트를 리스닝 함으로써 알림 요건을 재구성하는 것이다.

콜백에서의 알림은 메소드를 넘겨서 구성했지만 프라미스는 제어의 역전이 역전되어 foo() 에서 이벤트를 리스닝하고 있다가 알림은 받게 되면 다음으로 진행한다

```javascript
foo() {
    // somthing
}
on (foo 'complete') {
    // somthing
}
on (foo 'fail') {
    // somthing
}
```

위 의사코드를 보면 foo() 메서드에 이벤트 리스너를 설정한다. foo() 의 결과는 완료 아니면 실패이다.
foo() 는 호출부에서 이벤트를 받아 어떻게 처리할지 알 길이 없으니 아주 멋지게 관심사가 분리된다.

아쉽게도 자바스크립트는 이런 문법이 없다. 자연스러운 코드는 다음과 같이 표현이 된다.

```javascript
function foo(x) {
    // somthing
    // 이벤트 구독기를 생성하여 발행한다.
    return listener;
}
var evt = foo(42);
evt.on('completion', function() {
    // next
});
evt.on('failure', function() {
    // error
});
```

foo() 는 이벤트 구독기를 생성하여 반환하도록 명시되어 있고, 이는 두 이벤트 처리기를 각각 등록한다.
콜백 지향 코드와 정 반대로 foo() 에 콜밷 함수를 넘겨주는 대신 이벤트 구독기를 반환하고 여기에 콜백 함수를 넣어주는 것이다.

#### 3.1.2.1 프라미스 '이벤트'

이 evt 이벤트 구독기가 프라미스와 유사하다. 프라미스 식으로 앞 예제를 다루면 foo()는 프리미스 인스턴스를 생성하여 반환하고 이 프라미스를 리스닝하는 함수에 전해주면 된다.

```javascript
function foo(x) {
    // somthing
    return new Promise(function(resolve, reject) {
        // resolve, reject 중 한쪽을 호출하고 이들은 프라미스의 귀결 콜백 함수역활을 한다.
        // 생성자 노출 패턴의 모습으로 전달된 function 은 지연없이 바로 실행되고
        // resolve, reject 라고 이름 붙은 2개의 인자를 받는데 이게 프라미스의 귀결 함수이다.
    });
}

var p = foo(42);
bar(p);
baz(p);

function bar(fooPromise) {
    fooPromise.then(() => {}, () => {});
}   // baz 도 비슷한 형태
```

또는 단지 흐름 제어 신로로써 쓰일수도 있다

```javascript
function bar() {
    // foo 작업이 끝났으므로
    // bar 작업을 시작한다.
}

function oopsBar() {
    // foo 작업에 문제가 생겨서
    // bar 작업은 실행되지 않는다.
}

var p = foo(42);
p.then(bar, oopsBar);
// baz 도 똑같다.
```

앞의 예제와 뒤의 예제의 가장 큰 차이점은 에러 처리 방식이다. 전자는 foo() 의 이룸/버림 여부와 상관없이 무조건 bar() 를 호출하고 foo 실행이 실패할 경우엔 자체 로직이 처리한다.
반면 후자는 foo() 성공시에만 bar 를 호출하고 그 외의 경우 oopsBar 를 호출한다.

또한 then() 을 두 번 호추랗는 부분에서 프라미스는 일단 귀결이 되면 똑같은 결과를 유지하므로 몆번이고 계속 꺼내 쓸 수 있다.

## 3.2 데너블 덕 타이핑

프라미스는 then() 메서드를 가진 데너블 이라는 객체 또는 함수를 정의하여 판별하는 것으로 규정되었다.
어떤 값의 타입을 그 형태를 보고 짐작하는 타입 체크를 일반적인 용어로 덕 타이핑 이라고 하는데, "오리처럼 보이는 동물이 오리 소리를 낸다면 오리가 분명하다" 는 것이다.

## 3.3 프라미스 믿음

먼저 콜백만을 사용한 코드의 믿음성 문제를 되짚어보자.

1. 너무 일찍 콜백을 호출
2. 너무 늦게 콜백을 호출
3. 너무 적게, 아니면 너무 많이 콜백을 호출
4. 필요한 환경/인자를 정상적으로 콜백에 전달 못함
5. 발생 가능한 에러/예외를 무시함

프라미스 특성은 이와 같은 모든 일들에 대해 유용하고 되풀이하여 쓸 수 있는 해결책을 제시하게끔 설계됐다.

### 3.3.1 너무 빨리 호출

같은 작업이어도 어떨 때는 동기적으로, 어떨 때는 비동기적으로 끝나 경합 조건에 이르게 되는 코드를 확인하는 문제이다. 프라미스는 바로 이루어져도 (new Promise(function(resolve) {resolve(42)})) 프라미스의 정의상 동기적으로 볼수 없으니 이 문제는 영향받을 일이 없다. 따라서 then() 을 호출하면 프라미스가 이미 귀결된 이후라 해도 then() 에 건넨 콜백은 항상 비동기적으로만 부른다.

### 3.3.2 너무 늦게 호출

프라미스는 then() 에 등록한 콜백은 새 프라미스가 생성되면서 resolve(), reject() 중 어느 한쪽은 자동 호출하도록 스케줄링 된다. 이렇게 스케줄링된 두 콜백은 다음 비동기 시점에서 실행되므로, 지연될수는 없다. 예를 들면

```javascript
p.then(function() {
    p.then(function() {
        console.log('C');
    });
    console.log('A');
})
p.then(function() {
    console.log('B');
});
// A B C
```

여기서 프라미스 작동 원리 덕분에 C 가 B 를 앞지를 가능성은 없다.

#### 3.3.2.1 프라미스 스케줄링의 기벽

만일 별개의 두 프라미스에서 연쇄된 콜백 사이의 상대적인 실행 순서는 어떻게 될까?
두 프라미스 p1, p2 가 모두 귀결된 상태라면 p1.then(); p2.then() 에서 p1 콜백이 p2 콜백보다 먼저 실행될것같지만 애매한 경우가 존재한다.

```javascript
var p3 = new Promise(function(resolve, reject) {
    resolve('B');
});

var p1 = new Promise(function(resolve, reject) {
    resolve(p3);
});

var p2 = new Promise(function(resolve, reject) {
    resolve('A');
});

p1.then(function(v) {
    console.log(v);
})

p2.then(function(v) {
    console.log(v);
})
// A B
```

코드를 보면 p1 은 즉시값으로 귀결되지 않고 다른 프라미스인 p1 로 귀결되고 p3는 다시 'B' 값으로 귀결된다. 이때 p3 는 p1 로 비동기적으로 풀리므로 p1 콜백은 p2 콜백보다 비동기 잡 큐에서 후순위로 밀리게 된다.

### 3.3.3 한번도 콜백을 안 호출

우선, 프라미스가 스스로 귀결 사실을 알리지 못하게 막을 방도는 없다. 프라미스가 귀결되면 resolve/reject 둘 중 하나는 반드시 부른다. 그런데 어느 쪽으로도 귀결되지 않을 경우 경합이라는 상위 수준의 추상화를 이용하면 프라미스로 해결할수 있다.

```javascript
function timeoutPromise(delay) {
    // 주어진 시간이 지나면 promise reject 를 귀결하는 함수
}

Promise.race([
    foo(),
    timeoutPromise(3000)
])
.then(function() {
    // 시간 내에 성공
}, function(err) {
    // 시간 내에 실패
})
```

### 3.3.4 너무 가끔, 너무 종종 호출

프라미스는 정의상 단 한번만 귀결되며, 여러 차례 호출하려고 해도 오직 최초의 귀결만 취하고 이후 값은 조용히 무시된다. 또한 then() 에 등록한 콜백 또한 한번씩만 호출된다.

### 3.3.5 인자/환경 전달 실패

프라미스는 명시적인 값으로 귀결하지 않으면 undefined로 세팅되며, 콜백으로 반드시 전해진다.

### 3.3.6 에러/예외 삼키기

프라미스 귀결을 기다리는 도중 에러가 발생하면 예외를 잡아 프라미스를 강제로 버려준다.
에러 아닌 요소는 비동기적이면서 에러가 나면 동기적으로 반응하여, 문제를 효과적으로 차단해준다.

```javascript
var p = new Promise(function(resolve, reject) {
    foo.bar(); // undefined 의 bar 에 접근
    resolve(42);
});
p.then(funciton() {
    // 실행되지 않음
}, function(err) {
    console.log(err) // TypeError 예외 객체
});
```

그런데 만일 then 에서 예외가 발생하면 어떻게 될까?

```javascript
var p = new Promise(function(resolve, reject) {
    resolve(42);
});
p.then(funciton(val) {
    foo.bar(); // undefined 의 bar 에 접근
    console.log(val); // 실행되지 않음
}, function(err) {
    // 실행되지 않는다.
});
```

이 경우 p.then() 가 반환한 또 다른 프라미스에서 TypeError 예외가 나면서 버려지게 된다.

### 3.3.7 미더운 프라미스

프라미스는 콜백을 완전히 제거하는 장치가 아닌 콜백을 넘겨주는 위치를 달리해줄 뿐이다. foo()에 콜백을 바로 넘기지 않고 뭔가를 반환 받아 이 뭔가에 콜백을 전하는 것이다. 이때 이 받는 뭔가에 대한 믿음에 의심을 가질수 있다. 이 의심의 종지부는 Promise.resolve() 를 통해 해결할수 있다.
즉시값 또는 프라미스가 아닌 또는 데너블 이 아닌 값을 Promise.resolve() 에 건네면 이 값으로 이루어진 프라미스를 손에 넣게 된다. 즉 다음 코드에서 p1, p2 는 똑같다.

```javascript
var p1 = new Promise(funciton(resolve, rejcet) {
    resolve(42);
});
var p2 = Promise.resolve(42);
```

Promise.resolve() 에 진짜 프라미스가 넘어가도 결과는 마찬가지다.

```javascript
var p1 = Promise.resolve(42);
var p2 = Promise.resolve(p1);

p1 === p2 // true
```

더 중요한 사실은 데너블 값을 넘기면 그 값을 풀어보고 구체적으로 프라미스가 아닌 값이 나올때 까지 반복된다는 점이다. 다음 코드를 보자

```javascript
var p = {
    then: function(cb, errcb) {
        cb(42);
        errcb('smile');
    }
};

p.then(
    function fulfilled(val) {
        console.log(val);
    },
    function rejected(err) {
        console.log(err); // 실행하지 않을것으로 추정된 데너블
    }
);
```

p는 데너블이지만 프라미스처럼 동작하지 않는다. 중요한점은 데너블에서도 미덥지 못하는 경우가 존재하다는 것이다. 하지만 괜찮다. 어떤 p 라도 Promise.resolve() 에 넣으면 정규화하므로 안전한 결과를 기대할수 있다.

```javascript
Promise.resolve(p1)
.then(function fulfilled(val) {
        console.log(val);
    },
    function rejected(err) {
        console.log(err); // 실행하지 않는다.
    })
```

Promise.resolve() 는 데너블을 인자로 받아 데너블 아닌 값을 발견할때 까지 풀어봐서 믿을 만한 프라미스를 내놓는다.

## 3.4 연쇄 흐름

프라미스는 장난감 블록처럼 여러 개를 길게 늘어놓으면 일련의 비동기 단계를 나타낼수 있는데, 이는 다음 두가지 방식을 통해 가능하다

1. 프라미스에 then() 을 부를 때마다 생성하여 반환하는 새 프라미스를 계속 연쇄할 수 있다.
2. then()의 이룸 콜백 함수가 반환한 값은 어떤 값이든 자동으로 연쇄된 프라미스의 이룸으로 세팅된다.

먼저 예제 코드를 보자

```javascript
var p = Promise.resolve(21);

var p2 = p.then(function(v) {
    console.log(v); // 21
    return v + 2 // p2 는 이룸 (23)
});
p2.then(function(val) {
    console.log(val) // 23
});
```

v + 2 를 반환하면서 첫번째 then() 호출이 만들어준 신생 프라미스 p2 를 이룬다. p2 의 then() 을 호출하면 return v + 2 에서 이룸 값을 받는다.
비동기 시퀀스 전체적으로 보았을때 첫번째 then()은 1단계 두번째 then()은 2단계에 해당된다. 예제에서는 바로 return 문을 써서 값을 반환헤 값이 즉시 이루어졌지만 비동기적인 처리구조때문에 2단계가 1단계를 기다렸다 실행하고 싶다면 Promise 를 만들어 반환하면 된다.
이게 가능한 이유가 Promise.resolve() 가 재귀적으로 계속 풀어보기 때문이다.

```javascript
var p = Promise.resolve(21);

p.then(function(v) {
    console.log(v); // 21
    return new Promise(function(resolve, reject) {
        resolve(v + 2);
    })
})then(function(val) {
    console.log(val) // 23
});
```

이런 식으로 원하는 개수만큼 비동기 단계로 구성된 시퀀스를 만들어 다음 단계로 진행을 미룰수 있는것이다.
물론 단계별로 어떤 값을 전달할 필요는 없다. 명시적이지 않으면 undefined 가 할당되며, 연쇄에는 변함 없다. 다음 코드는 지연-프라미스 생성을 일반화 시킨 유틸리티 코드이다.

```javascript
function delay(time) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve, time);
    });
}

delay(100)
.then(function() {
    console.log('100ms 초 후');
    return delay(200);
})
.then(function() {
    console.log('200초 후');
})
.then(function() {
    console.log('다음 단계');
})
```

다음은 타이머 대신 AJAX 요청을 하는 예제이다.

```javascript
// ajax({url}, {callback}) 같은 유틸리티가 있다고 하자

// Promise-Aware ajax
function request(url) {
    return new Promise(function(resolve, reject) {
        ajax(url, resolve);
    });
}

request('url')
.then(function(res) {
    return request(res);
})
.then(function(res2) {
    console.log(res2);
})
```

이러한 프라미스 연쇄는 다단계 비동기 시퀀스에서 흐름 제어 뿐만 아니라 단계와 단계 사이에 메세지를 전달하는 채널로도 쓰인다. 만일 프라미스 도중 문제가 발생하게 되는 코드를 한번 보자

```javascript
request('url')
.then(function(res) {
    foo.bar() // undefined 접근
    return request(res);
})
.then(function fulfilled(res2) {
    // 실행되지 않는다.
}, function reject(err) {
    console.log(err) // TypeError
    return 42;
})
.then(function(msg) {
    console.log(msg) // 42
})
```

2단계 에서 에러가 나면 3단계에서 이를 잡아 어떤 값을 반환해 4단계부터 다시 이룸 상태로 돌아가도록 한다. 만일 reject 버림 함수를 선언하지 않았다면 function(err) { throw err} 이 있다고 가정하고 예외를 처리한다. 물론 fulfilled 이룸 함수를 선언안해도 function(v) {return v;} 가 있다 가정하고 전달하게 된다. 이 경우에는 .catch(function(err) {}) 로 줄여 쓸수도 있다.

흐름 제어를 연쇄할 수 있는 프라미스 고유의 특징을 정리해보면

1. then() 을 호출하면 그 결과 자동으로 새 프라미스를 생성하여 반환한다.
2. 이룸/버림 처리기 안에서 어떤 값을 반환하거나 예외를 던지면 이에 따라 새 프라미스가 귀결된다.
3. 이룸/버림 처리기가 반환한 프라미스는 풀린 상태로 그 귀결 값이 무엇이든 간에 결국 현재의 then()에서 반환된 연쇄된 프라미스의 귀결 값이 된다.

순차적인 연쇄 표현은 콜백의 복잡한 코드에 비하면 확실히 개선되었다. 하지만 then, function 등 의 코드를 남발하는거는 여전하다. 이는 뒤의 제너레이터를 통해 더 멋지게 표현할수가 있다.

### 3.4.1 용어 정의: 귀결, 이룸, 버림

프라미스 생성자는 resolve, reject 인자를 받는다. reject 는 헷갈림이 없다. 그러나 resolve 라는 단어는 조금 애매하다. 이는 귀결과 연관된 단어로 프라미스에 최종 값/상태를 지정한다는 의미로 사용한다. 이는 이미 여러 차례 프라미스 이름/버림 을 귀결이라는 말로 표현하고 있었다. 만일 프라미스 이룸 전용으로 이 인자를 사용할 의도였다면 resolve 보단 fulfill 이 더 정확하지 않을까?
다음 코드를 보자

```javascript
var fulfilledPr = Promise.resolve(42);
var rejectedPr = Promise.reject("허걱");
```

Promise.resolve() 는 주어진 값으로 귀결된 프라미스를 생성한다. 예제의 42는 프라미스 아닌/데너블 아닌 값으로 프라미스 fulfilledPr 은 42 값으로 이루어진다. rejectedPr 는 "허걱" 이라는 버림 사유로 폐기가 된다. 이제 귀결 이라는 단어가 이룸 아니면 버림이라는 이유를 보자

```javascript
var rejectedTh = {
    then: function(resolved, rejected) {
        rejected('허격');
    }
}

var rejectedPr = Promise.resolve(rejectedTh);
```

이미 설명했듯이 Promise.resolve 는 프라미스를 넘기면 도로 반환하고, 데너블을 넘기면 결과가 나올때 까지 풀어본다. 위 코드는 풀어본 결과가 버림이므로 반환한 프라미스도 버림이라는 소리이다. 그래서 resolve 라는 메서드명이 나온것이다.

```javascript
var rejectedPr = new Promise(function(resolve, reject) {
    resolve(Promise.reject('fail'));
})

rejectedPr.then(
    function fulfilled() {
        // 실행되지 않는다.
    },
    function rejectd(err) {
        console.log(err) // fail
    }
)
```

## 3.5 에러 처리

프라미스 버림이 비동기 처리에 있어서 에러 처리를 해주는지 확인을 해보았었다. 이 부분을 좀더 자세히 살펴보자. 동기적인 try...catch 구문은 개발자들이 익숙한 일반적인 에러 처리 형태이다. 하지만 비동기 프로그램에서는 무용지물이다. 이 문제는 제너레이터에서 다시 다룬다.

콜백 세계에서는 에러-우선 콜백 스타일 이리고 함수에 전달한 첫번째 인자 err 를 통해 에러 신호를 감지하는것이 있는데, 이는 콜백 지옥을 피하기 어렵다. 프라미스 에러 처리하는 부분은 분산-콜백 스타일로, 이룸/버림 각각의 콜백을 지정하여 에러를 처리한다. 하지만 이 역시 문제가 없지는 않다.

```javascript
var p = Promise.resolve(42);

p.then(
    function fulfilled(msg) {
        // 숫자에는 문자열 함수가 없으니 에러가 난다.
        console.log(msg.toLowerCase());
    },
    function rejectederr(err) {
        console.log(err);
    }
)
```

msg.toLowerCase() 에서 문법 오류가 발생했는데, 프로세스가 어떻게 될까? 에러 처리기 소속은 프라미스 p 이고 이미 42로 이루어진 상태이므로 에러는 p.then 이 반환한 프라미스만 가능한데 포착할 방법이 없다. 즉, 에러가 조용히 묻혀버리기 쉬운 구조이다.

### 3.5.1 절망의 구덩이

제프 앳우드 : "프로그래밍 언어는 대부분 개발자가 사고를 치면 '절망의 구덩이' 에 빠져 대가를 치라는 방향으로 설계되어 있어서 정신을 바짝 차리고 코딩하여야 한다."  이는 프로그램이 예상대로 처리되도록 '성공의 구덩이'를 기본적으로 파놓고 프로그램 실행을 실패하도록 만들어야 한다는 말이다.

프라미스 에러 처리는 절망의 구동이 방식으로 설계되어 있다. 그래서 개발자가 신경쓰지 않으면 에러가 나도 무시될수가 있다. 그래서 일부 개발자들은 프라미스 마지막에 .catch() 를 넣어야 한다고 주장하는 개발자가 있긴한데, 이 역시 .catch() 에서 나는 에러를 잡을 방법이 없다.

### 3.5.2 잡히지 않은 에러 처리

프라미스 연쇄 끝에 done() 을 붘여 버림 처리기 내부에서 에러가 나면 잡히지 않는 전역 에러로 던지는 방법이 있다. 그러나 이는 표준이 아니기 때문에 보편적인 해결 방안과는 거리가 있다. 결국 브라우저의 도움으로 개발자 콘솔창에 표시하는데, 바로 가비지 콜렉션 기능 이다. 브라우저는 프라미스 객체를 추적하여 언제 가비지를 수거할지 알고 있으며, 프라미스가 버려지면 그 사유가 잡히지 않는 에러이면 콘솔창에 표시해줄수 있다.

### 3.5.3 성공의 구덩이

위에서 말한바와 같이 프라미스는 잡/이벤트 루프 틱 시점에 에러처리가가 등록되어 있지 않을 경우 모든 버림을 개발자 콘솔창에 알리도록 되어있다. 또한 버림 상태를 유지하고 싶다면 defer() 를 호출해 자동 에러 알림 기능을 끄는 방법도 있다. 이러한 설계를 성공의 구덩이라고 하는데 이는 의도적으로 에러 처리를 나중으로 미루겠다는 의도이다. 주의할점은 개발자가 까먹고 버림을 처리하지 못했을 때 이다.

## 3.6 프라미스 패턴

앞서서 프라미스 연쇄의 시퀀스 패턴을 계속 보았었다. 이런 패턴들을 잘 활용하면 난해한 프로그램도 더 추론적이고 관리하기 쉽게 코딩할수 있다.

### 3.6.1 Promise.all([])

비동기 시퀀스는 주어진 시점에서 단 한 개의 비동기 작업만 가능하다. 2개 이상의 병렬/동시 작업이 끝날때 까지 진행하지 않고 대기하는 프라미스 API all([]) 이 있다.

AJAX 2개를 동시에 요청한 뒤에 순서에 상관없이 완료될때 까지 기다렸다가 3번째 AJAX 요청하는 코드를 보자

```javascript
// request() 는 프라미스-인식형 AJAX 유틸리티
var p1 = request('url');
var p2 = request('url2');

Promise.all([p1, p2])
.then(function(msgs) {
    return request('url3' + msgs.join(','));
})
.then(function(msg) {
    console.log(msg);
})
```

Promise.all([]) 은 프라미스 인스턴스들이 담긴 배열 하나를 인자로 받고 호출 결과를 배열에 나열한 순서대로 기록한다. 만일 단 한개라도 버려진다면 Promise.all([]) 도 버려지며 다른 프라미스도 무효가 된다.

### 3.6.2 Promise.race([])

때로는 결승선을 통과한 최초의 프라미스만 인정하고 나머지는 무시해야하는 경우가 있다. 이른바 Latch 라는 패턴으로 프라미스에서는 경합이라고 한다. 만일 빈 배열을 넘길 경우 결코 귀결되지 않으므로 주의해야한다.

```javascript
// request() 는 프라미스-인식형 AJAX 유틸리티
var p1 = request('url');
var p2 = request('url2');

Promise.race([p1, p2])
.then(function(msg) {
    // p1, p2 중 하나만이 경합의 승자가 된다.
    return request('url3' + msg;
})
.then(function(msg) {
    console.log(msg);
})
```

#### 3.6.2.1 타임아웃 경함

Promise.race([]) 를 이용하여 프라미스 타임아웃 패턴을 구현할수 있다.

```javascript
function timeoutPromise(delay) {
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            reject('timeout');
        }, delay);
    });
}

Promise.race([foo(), timeoutPromise(3000)])
.then(function() {
    // foo() 가 시간안에 이루어졌다.
}, function(err) {
    // 시간안에 이루지 못했다.
})
```

여기서 시간안에 이루지 못해 폐기/무시 된 프라미스에 대해 작동관점에서 어떻게 될까? 프라미스는 외부적인 불변성에 관란 믿음때문에 조용히 묻혀버릴 뿐이다. 하지만 만일 foo() 가 어떤 자원을 사용하려고 예약한 상태인데 타임아웃이 걸린 상황이라면 자원을 어떻게 놓아줄수 있을까?

그래서 프라미스에 finally() 같은 콜백을 등록하도록 제안이 된다.

### 3.6.3 all([])/rece([]) 의 변형

* any([]) : 버림은 모두 무시하며, 하나만 이루어지면 된다.

## 3.7 프라미스 API 복습

지금까지 배운 ES6 Promise API를 정리해보자

### 3.7.1 new Promise() 생성자

Promise 생성자는 항상 new 와 함께 사용해야 하며 동기적으로 호출할 콜백 함수를 전달해야한다.
이 함수는 다시 프라미스를 귀결 처리할 콜백 2개를 넘기는데 resolve(), reject() 라고 명명한다.

```javascript
var p = new Promise(function(resolve, rejcet) {
    // resolve() 는 프라미스의 귀결
    // reject() 는 프라미스를 버린다.
});
```

reject() 는 프라미스를 버리지만 resolve 는 넘어온 값을 보고 이룸/버름 중 한 가지로 처리한다.
만일 즉시값, 프라미스 아닌/데너블 아닌 값이 들어오면 그 값으로 이루어진다. 반면 진짜 프라미스/데너블 값이 전달되면 재귀적으로 풀어보고 최종 값이 귀결된다.

### 3.7.2 Promise.resolve(), Promise().reject()

Promise.reject() 는 버려진 프라미스를 생성하는 지름길이다. 따라서 다음 코드의 두 변수는 본질적으로 동일하다

```javascript
var p1 = new Promise(function(resolve, reject) {
    reject('fail');
});

var p2 = Promise.reject('fail');
```

Promise.resolve() 는 이미 이루어진 프라미스를 생성하는 용도로 쓰인다. 데너블 값이 들어오면 재귀적으로 풀어보고 최종 귀결 값이 반환된 프라미스에 해당된다.

```javascript
var fulfilledTh = {
    then: function(cb) {cb(42);}
};
var rejectTh = {
    then: function(cb, errcb) {errcb('oops');}
};

var p1 = Promise.resolve(fulfilledTh); // 이룸 프라미스
var p2 = Promise.resolve(rejectTh); // 버림 프라미스
```

Promise.resolve() 에 진짜 프라미스를 넣으면 아무일도 일어나지 않는다. 당연히 오버헤드도 없다

### 3.7.3 then()과 catch()

then()은 하나 또는 2개의 인자를 받는데 첫번째는 이룸 콜백, 두번째는 버림 콜백을 받는다. 만일 누락한다면 기본 콜백으로 대체된다.

catch()는 버림 콜백 하나만 받고 이룸 콜백은 기본 이룸 콜백으로 대체된다. 즉 then(null, reject()) 와 동잉하다

이 두 메서드는 새 프라미스를 만들어 반환하므로 연쇄 형태로 흐름 제어를 표현할수 있다.

### 3.7.4 Promise.all([]) 과 Promise.race([])

Promise.all([]) 은 주어진 모든 프라미스들이 이루어져야 메인 프라미스도 이루어지고 단 하나라도 버려지게 되면 메인 반환 프라미스 역시 폐기 된다. 이루어 지게 되면 각 프라미스의 이룸값이 담긴 배열을, 버려지면 처음 버려진 프라미스의 버림 사유를 돌려 받는다.

Promise.race([]) 은 이룸이든 버림이든 최초의 귀결된 프라미스만이 귀결된다.

```javascript
var p1 = Promise.resolve(42);
var p2 = Promise.resolve('Hello world');
var p3 = Promise.reject('fail');

Promise.race([p1, p2, p3])
.then(function(msg) {
    console.log(msg); // 42
});

Promise.all([p1. p2. p3])
.catch(function(err) {
    console.log(err); // fail
});

Promise.all([p1, p2])
.then(function(msgs) {
    console.log(msgs); // [42, 'Hello world']
});
```

## 3.8 프라미스 한계
